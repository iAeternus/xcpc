# 二分

```c++
int bisearch(int a[],int n,int x)
{
    int left = 0,right = n-1;
    while(left<=right)
    {
        int mid = (left+right)>>1;
        if(a[mid] == x)
            return mid;
        if(x > a[mid])
            left = mid+1;
        else
            right = mid- 1;
	}
    return -1;
}

```

二分答案常见步骤

1、证明问题单调性。

2、确定上下界

3、设计check()函数。

4、上下界之内二分答案。

# 三分

 	 	

# 区间最值

可以使用树状数组解答，但一般用st、线段树和笛卡尔树更方便
下面用st算法
解答静态区间最值，输出给定l,r最大值和最小值之差

```c++
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
const int N=5e4+1;
int Log2[N];
int n,q;
int arr[N];
int dp_min[N][17],dp_max[N][17];
void init()
{
    Log2[0]=-1;
    for(int i=1;i<=n;i++)
        Log2[i]=Log2[i>>1]+1;;
    for(int i=1;i<=n;i++)
    {
        dp_max[i][0]=arr[i];
        dp_min[i][0]=arr[i];
    }
    int p=Log2[n];
    for(int k=1;k<=p;k++)
        for(int s=1;s+(1<<k)<=n+1;s++)
        {
            dp_min[s][k]=min(dp_min[s][k-1],dp_min[s+(1<<(k-1))][k-1]);
            dp_max[s][k]=max(dp_max[s][k-1],dp_max[s+(1<<(k-1))][k-1]);
        }
}
int solve(int l,int r)
{
    int x,y;
    int k=Log2[r-l+1];
    x=max(dp_max[l][k],dp_max[r-(1<<k)+1][k]);
    y=min(dp_min[l][k],dp_min[r-(1<<k)+1][k]);
    return x-y;
}
int main()
{
    int l, r,ans;
    cin>>n>>q;
    for(int i=1;i<=n;i++)
        cin>>arr[i];
    init();
    while(q--)
    {
        cin>>l>>r;
        ans=solve(l,r);
        cout<<ans<<endl;
    }
    return 0;
}
```

st算法思想为一个区间变成两个有重叠区间的答案，故适用于重复贡献的题目如最大值最小值，区间最大公约数等

# 树状数组

## 单点修改+区间查询

```c++
#include <iostream>
using namespace std;
const int N = 1e5 + 10;
int a[N],c[N];
int n,m;
int lowbit(int x)
{
	return x & -x;
}
void add(int x,int k)
{
	for(int i = x;i <= n;i += lowbit(i))
	{
		c[i] += k;
	}
}
int sum(int x)
{
	int res = 0;
	for(int i = x;i;i -= lowbit(i))
	{
		res += c[i];
	}
	return res;
}
int main()
{
    cin >> n >> m;
	for(int i = 1;i <= n;i++)
	{
		cin >> a[i];
		add(i,a[i]);
	}
	while(m--)
	{
		int l,r;
		cin >> l >> r;
		cout << sum(r) - sum(l - 1) << endl;
	}
	return 0;
}
```

## 区间修改+区间查询

定义差分数组为d,原数组为a则有：
$
d_i=a_i-a_{i-1}(1\leq i\leq n)
$
$
a_i=\sum_{j=1}^{i}d_j(1\leq i\leq n)
$
$
\sum_{i=1}^{k}a_i=\sum_{i=1}^{k}\sum_{j=1}^{i}d_j=
\sum_{j=1}^{k}\sum_{i=j}^{k}d_j=k\sum_{i=1}^{k}d_i-\sum_{i=1}^{k}(i-1)d_i
$
故用两个树状数组维护$d_i$和$(i-1)\cdot d_i$即可

```c++
//区间修改，区间查询树状数组做法
#include<iostream>
#include<cstring>
using namespace std;
typedef long long ll;
const int N=1e5+10;
ll tr1[N],tr2[N];
int n,m;
int lowbit(int x)
{
    return x&(-x);
}
void update1(int x,ll d)
{
    while(x<=n)
    {
        tr1[x]+=d;
        x+=lowbit(x);
    }
}
ll sum1(int x)
{
    ll ans=0;
    while(x)
    {
        ans+=tr1[x];
        x-=lowbit(x);
    }
    return ans;
}
void update2(int x,ll d)
{
    while(x<=n)
    {
        tr2[x]+=d;
        x+=lowbit(x);
    }
}
ll sum2(int x)
{
    ll ans=0;
    while(x)
    {
        ans+=tr2[x];
        x-=lowbit(x);
    }
    return ans;
}
int main()
{
    cin>>n>>m;
    int pre=0,a;
    for(int i=1;i<=n;i++)
    {
        scanf("%lld",&a);
        update1(i,a-pre);
        update2(i,(i-1)*(a-pre));
        pre=a;
    }
    while(m--)
    {
        int p,l,r;
        ll d;
        scanf("%d",&p);
        if(p == 1)
        {
            scanf("%d%d%lld",&l,&r,&d);
            update1(l,d);
            update1(r+1,-d);
            update2(l,d*(l-1));
            update2(r+1,-d*r);
        }
        else if(p == 2)
        {
            scanf("%d%d",&l,&r);
            printf("%lld\n",r*sum1(r)-sum2(r)-(l-1)*sum1(l-1)+sum2(l-1));
        }
    }
    return 0;
}
```

## 区间最值

hdu1754

Q a b 查询区间[a,b]的最大值
U a b 修改第a个数为b

```c++
#include<iostream>
#include<cstring>
#include<algorithm>

using namespace std;
const int N=2e5+10;
int a[N],tr[N];
int n,m;
int lowbit(int x)
{
    return x&(-x);
}
void update(int x,int val)
{
    while(x<=n)
    {
        tr[x]=val;
        for(int i=1;i<lowbit(x);i<<=1)
        {
            tr[x]=max(tr[x],tr[x-i]);
        }
        x+=lowbit(x);
    }
}
int query(int l,int r)
{
    int res=0;
    while(l<=r)
    {
        res=max(res,a[r]);
        r--;
        while(r-l>=lowbit(r))
        {
            res=max(res,tr[r]);
            r-=lowbit(r);
        }
    }
    return res;
}
int main()
{
    while( ~scanf("%d%d",&n,&m))
    {
        memset(tr,0,sizeof tr);
        for(int i=1;i<=n;i++)
        {
            scanf("%d",&a[i]);
            update(i,a[i]);
        }
        while(m--)
        {
            char op[2];
            int x,y;
            scanf("%s%d%d",op,&x,&y);
            if(*op=='Q')printf("%d\n",query(x,y));
            else
            {
                a[x]=y;
                update(x,y);
            }
        }
    }
    return 0;
}
```

## 二维区间修改+区间查询

类似于上述方法推导可知维护四个数组即可
缺点是空间耗费较大

```c++
#include<iostream>
#include<cstring>
#include<algorithm>

using namespace std;
const int N=2055;
int t1[N][N],t2[N][N],t3[N][N],t4[N][N];
int n,m;
int lowbit(int x)
{
    return x&(-x);
}
void update(int x,int y,int d)
{
    for(int i=x;i<=n;i+=lowbit(i))
        for(int j=y;j<=m;j+=lowbit(j))
        {
            t1[i][j]+=d,t2[i][j]+=x*d;
            t3[i][j]+=y*d,t4[i][j]+=x*y*d;
        }
}
int sum(int x,int y)
{
    int res=0;
    for(int i=x;i>0;i-=lowbit(i))
        for(int j=y;j>0;j-=lowbit(j))
        {
            res+=(x+1)*(y+1)*t1[i][j]-(y+1)*t2[i][j]-(x+1)*t3[i][j]+t4[i][j];
        }
        return res;
}
int main()
{
    char ch[2];
    scanf("%s",ch);
    cin>>n>>m;
    while(~scanf("%s",ch))
    {
        int a,b,c,d,delta;
        scanf("%d%d%d%d",&a,&b,&c,&d);
        if(ch[0]=='L')
        {
            scanf("%d",&delta);
            update(a,b,delta),update(c+1,b,-delta);
            update(a,d+1,-delta),update(c+1,d+1,delta);
        }
        else printf("%d\n",sum(c,d)-sum(a-1,d)-sum(c,b-1)+sum(a-1,b-1));
    }
    return 0;
}
```

## 求逆序对(离散化)

如果遇到相同的数字，离散化时，让先出现的更小
把数字看成树状数组的下标。每处理一个数字，就把下标对应元素值加1，统计前缀和就是逆序对的数量

```c++
#include<iostream>
#include<cstring>
#include<algorithm>

using namespace std;
typedef long long LL;
const int N=5e5+5;
int tr[N],r[N],n;
int p[N];
int lowbit(int x)
{
    return x&(-x);
}
void update(int x,int d)
{
    for(int i=x;i<=n;i+=lowbit(i))
        tr[i]+=d;
}
LL sum(int x)
{
    LL res=0;
    while(x>0)
    {
        res+=tr[x];
        x-=lowbit(x);
    }
    return res;
}
void lisanhua(int a[])
{
    for(int i=1;i<=n;i++)p[i]=i;
    sort(p+1,p+1+n,[&](int x,int y)
    {
        if(a[x]==a[y])return x<y;
        return a[x]<a[y];
    });
    for(int i=1;i<=n;i++)a[p[i]]=i;
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)scanf("%d",&r[i]);
    lisanhua(r);
    LL ans=0;
    for(int i=n;i>0;i--)
    {
        update(r[i],1);
        ans+=sum(r[i]-1);
    }
    printf("%lld\n",ans);
    return 0;
}

```

# 线段树（txy)



# 线段树

<img src="C:\Users\ZA\Desktop\9FX}HI8`1~XJA8C6_V8%K8R.png" alt="./" style="zoom:25%;" />

线段树每层结点只会选择两次，由于区间是连续的，如果选择了三次，那么中间的结点会和他一个相邻的结点变成父亲的结点，从而变成上一层结点了。

线段树中空间开4倍

对于长为 n的序列，显然以其构建的线段树有 n个叶子节点，此时线段树高度为$$k = [\log_2n]+1$$

至多有$$2^k−1$$ 个结点，即有$$2^{[\log_2n]+1}-1$$个结点，当$$log_2n$$为整数时，结点数为$$2n-1$$，当$$log_2n$$不为整数时，结点数为$$2^{[\log_2n]+2}-1$$，即$$4n-1$$。

线段树标号 左儿子为父亲号码乘2，右儿子为父亲号码乘2加1

第一层为    1 

第二层为   2 3 

第三层为4 5 6 7

区间修改中为什么要加v[i]

v[i]表示线段树递归的最终区间每个数都要加k，如果还能往下递归，这样会浪费时间，于是我用一个v[i]表示下面结点都要加v[i]；

因此f[k]每次都加了全部修改值，但是在最终区间是不加的，这时候要用到v[i]。

v[i]为当前结点全部加了k，并且下面结点也加k，f[i]当前结点k我已经全部加上去了，但是下面结点加没加不知道。v[i]标记下面所有结点都要加k，用标记代替了递归。

函数中k为当前查询结点号，一开始从顶点开始查询，默认为1，lr为结点表示的区间默认为（1，n),

标记下放

由于v[k]表示当前树的结点以及子孙结点都要加v[k]，那么可以把当前结点的v[k]加上去，然后当前结点的v[k]清零，子结点的v[k]加上父结点的v[k]。

##### 建树

```c++
void bulidtree(int k,int l,int r)//标号为1的点的区间开始建树bulidtree(1,1,n)
{
    v[k] = 0;
	if(l == r)
	{
		f[k] = a[l];//两端和相同区间和等于本身
		return;
	}
	int m = (l + r)>>1;
	bulidtree(k + k, l, m);
	bulidtree(k + k + 1, m + 1, r);
	f[k] = f[k + k + 1] + f[k + k];
}
```

##### 单点修改(某个数值改变)

```cpp
void add(int k,int l,int r,int x,int y)//k结点对应的区间上的下标为x的数上，x肯定在lr之间
{
	f[k]+=y;//包含下标的x的区间中的结点都要加y;
	if(l == r)
		return;
	int m = (l+r)>>1;
	if(x <= m)
	{
		add(k + k,l,m,x,y);
	}
	else
	{
		add(k + k + 1,m + 1,r,x,y);
	}
	
}
```

##### 单点查询(查询某个数值)(可以套用多点)

```c++
long long chaxun(int k,int l,int r,int x,int p)
{
	p += v[k];
	if(l == r)
	{
		return f[k]+p;
	}
	int m = (l + r)>>1;
	if(x <= m)
	{
		return chaxun(k + k, l, m, x, p);
	}
	else
	{
		return chaxun(k + k + 1, m + 1, r, x, p);
	}
}
```

##### 区间修改(区间里的数值发生改变)

```c++
void insert(int k,int l,int r,int x,int y,long long z)//l-r区间里的xy区间加上z,k为当前查询区间
{
	if(l == x&&r == y)
	{
		v[k] += z;
		return;
	}
	f[k] += (y - x + 1) * z;//区间长度每个加z
	int m = (l + r)>>1;
	if(y <= m)
	{
		insert(k + k, l, m, x, y, z);
	}
	else
	{
		if(x > m)
		{
			insert(k + k + 1, m + 1, r, x, y, z);
		}
		else
		{
			insert(k + k, l, m, x, m, z);
			insert(k + k + 1, m + 1, r, m + 1,y,z);
		}
	}
}
```

标记下传

```c++
void insert(int k,int l,int r,int x,int y,long long z)//l-r区间里的xy区间加上z,k为当前查询区间
{
	if(l == x && r == y)
	{
		v[k] += z;
		return;
	}
	if(v[k])
	{
		v[k + k] += v[k];
		v[k + k + 1] += v[k];
		v[k] = 0;
	}
	int m = (l + r)>>1;
	if(y <= m)
	{
		insert(k + k, l, m, x, y, z);
	}
	else
	{
		if(x > m)
		{
			insert(k + k + 1, m + 1, r, x, y, z);
		}
		else
		{
			insert(k + k, l, m, x, m, z);
			insert(k + k + 1, m + 1, r, m + 1, y, z);
		}
	}
	//标记回收 
	f[k] = f[k + k] + v[k + k] * (m - l + 1) + f[k + k + 1] + v[k + k + 1] * (r - m);
}
```



##### 区间查询

1.不带v[i]

```c++
long long calc(int k,int l,int r,int s,int t)//k结点代表lr的区间，求st的和
{
	if(l==s && r==t)
	{
		return f[k];
	}
	int m = (l + r)>>1;
	if(t <= m)
	{
		return calc(k + k, l, m, s, t);
	}
	else
	{
		if(s > m)
			return calc(k + k + 1, m + 1, r, s, t);
		else
			return calc(k + k, l, m, s, m) + calc(k + k + 1, m + 1, r, m + 1, t);	
	}
}
```

2.带v[i]

```c++
long long  calc(int k,int l,int r,int x,int y,long long p)//k结点代表lr的区间，求st的和
{
	p += v[k];
	if(l == x&&r == y)
	{
		return p * (r - l + 1) + f[k];
	}
	int m = (l + r)>>1;
	if(y <= m)
	{
		return calc(k + k, l, m, x, y, p);
	}
	else
	{
		if(x > m)
			return calc(k + k + 1, m + 1, r, x, y, p);
		else
			return calc(k + k, l, m, x, m, p) + calc_1(k + k + 1, m + 1, r, m+1, y, p);	
	}
}
```

3.标记下传

```c++
long long calc(int k,int l,int r,int s,int t)//k结点代表lr的区间，求st的和
{
	if(l==s&&r==t)
	{
		return f[k] + v[k] * (r - l + 1);
	}
	if(v[k])//标记下移
	{
		v[k + k] += v[k];
		v[k + k + 1] += v[k];
		v[k] = 0;
	}
	int m = (l + r)>>1;
	long long res = 0;//记录查询结果,不能直接return,因为没有修改f的值
	if(t <= m)
	{
		res = calc(k + k,l,m,s,t);
	}
	else
	{
		if(s > m) 
			res = calc(k + k + 1, m + 1, r, s, t);
		else
			res = calc(k + k, l, m, s, m) + calc(k + k + 1, m + 1, r, m+1, t);	
	}
	f[k] = f[k + k] + v[k + k] * (m - l + 1) + f[k + k + 1] + v[k + k + 1] * (r - m);
	return res;//f修改完后return结果
}
```

在insert中已经标记下传了，在calc中也需要下传，因为insert中的最后一结点并没有执行下传操作。

标记下移一般自己写函数。

# 主席树

主要应用于求第k小(大)问题

## 题目描述

如题，给定 $n$ 个整数构成的序列 $a$，将对于指定的闭区间 $[l, r]$ 查询其区间内的第 $k$ 小值。

## 输入格式

第一行包含两个整数，分别表示序列的长度 $n$ 和查询的个数 $m$。  
第二行包含 $n$ 个整数，第 $i$ 个整数表示序列的第 $i$ 个元素 $a_i$。   
接下来 $m$ 行每行包含三个整数 $ l, r, k$ , 表示查询区间 $[l, r]$ 内的第 $k$ 小值。

## 输出格式

对于每次询问，输出一行一个整数表示答案。

## 样例 #1

### 样例输入 #1

```
5 5
25957 6405 15770 26287 26465 
2 2 1
3 4 1
4 5 1
1 2 2
4 4 1
```

### 样例输出 #1

```
6405
15770
26287
25957
26287
```

## 数据规模与约定

- 对于 $20\%$ 的数据，满足 $1 \leq n,m \leq 10$。
- 对于 $50\%$ 的数据，满足 $1 \leq n,m \leq 10^3$。
- 对于 $80\%$ 的数据，满足 $1 \leq n,m \leq 10^5$。
- 对于 $100\%$ 的数据，满足 $1 \leq n,m \leq 2\times 10^5$，$0\le a_i \leq 10^9$，$1 \leq l \leq r \leq n$，$1 \leq k \leq r - l + 1$。

```c++
#include<iostream>
#include<cstring>
#include<algorithm>

using namespace std;
const int N=2e5+10;
int cnt=0;
int a[N],b[N],root[N];
struct
{
    int l,r,sum;
}tr[N<<5];
int build(int pl,int pr)
{
    int p=++cnt;
    tr[p].sum=0;
    int mid=pl+pr>>1;
    if(pl<pr)
    {
        tr[p].l=build(pl,mid);
        tr[p].r=build(mid+1,pr);
    }
    return p;
}
int update(int pre,int pl,int pr,int x)
{
    int p=++cnt;
    tr[p].l=tr[pre].l;
    tr[p].r=tr[pre].r;
    tr[p].sum=tr[pre].sum+1;
    int mid=pl+pr>>1;
    if(pl<pr)
    {
        if(x<=mid)tr[p].l=update(tr[pre].l,pl,mid,x);
        else tr[p].r=update(tr[pre].r,mid+1,pr,x);
    }
    return p;
}
int query(int u,int v,int pl,int pr,int k)
{
    if(pl==pr)return pl;
    int x=tr[tr[v].l].sum-tr[tr[u].l].sum;
    int mid=pl+pr>>1;
    if(pl<pr)
    {
        if(x>=k)return query(tr[u].l,tr[v].l,pl,mid,k);
        else return query(tr[u].r,tr[v].r,mid+1,pr,k-x);
    }
}
int main()
{
    int n,m,k;
    cin>>n>>m;
    for(int i=1;i<=n;i++)cin>>a[i],b[i]=a[i];
    sort(b+1,b+n+1);
    int size=unique(b+1,b+n+1)-b-1;
    root[0]=build(1,size);
    for(int i=1;i<=n;i++)
    {
        int x=lower_bound(b+1,b+1+size,a[i])-b;
        root[i]=update(root[i-1],1,size,x);
    }
    while(m--)
    {
        int l,r;
        cin>>l>>r>>k;
        int idx=query(root[l-1],root[r],1,size,k);
        cout<<b[idx]<<endl;
    }
    return 0;
}
```

## TTM - To the moon


一个长度为 $N$ 的数组 $\{A\}$，$4$ 种操作 ：

- `C l r d`：区间 $[l,r]$ 中的数都加 $d$ ，同时当前的时间戳加 $1$。

- `Q l r`：查询当前时间戳区间 $[l,r]$ 中所有数的和 。

- `H l r t`：查询时间戳 $t$ 区间 $[l,r]$ 的和 。

- `B t`：将当前时间戳置为 $t$ 。

　　所有操作均合法 。

ps：刚开始时时间戳为 $0$

输入格式，一行 $N$ 和 $M$，接下来 $M$ 行每行一个操作

输出格式：对每个查询输出一行表示答案

数据保证：$1\le N,M\le 10^5$，$|A_i|\le 10^9$，$1\le l \le r \le N$，$|d|\le10^4$。在刚开始没有进行操作的情况下时间戳为 $0$，且保证 `B` 操作不会访问到未来的时间戳。

由 @bztMinamoto @yzy1 提供翻译

### 题目描述

### 输入格式

```
n m
A1 A2 ... An
... (here following the m operations. )
```

### 输出格式

`... (for each query, simply print the result. )`

### 样例 #1

#### 样例输入 #1

```
10 5
1 2 3 4 5 6 7 8 9 10
Q 4 4
Q 1 10
Q 2 4
C 3 6 3
Q 2 4
```

#### 样例输出 #1

```
4
55
9
15
```

### 样例 #2

#### 样例输入 #2

```
2 4
0 0
C 1 1 1
C 2 2 -1
Q 1 2
H 1 2 1
```

#### 样例输出 #2

```
0
1
```

如果没有时间t则说标准线段树模板题，有了t只需按照主席树模板来即可，注意因为是动态开点，标记下传会效率大幅降低考虑标记永久化，即只需在查询时把路径上的标记依次加入答案

```c++
#include<iostream>
#include<cstring>
#include<algorithm>

using namespace std;
typedef long long ll;
const int N=1e5+10;
struct Node
{
    int l,r;
    ll sum;
    int tg;
}tr[N<<5];
int root[N];
int cnt,now;
int build(int l,int r)
{
    int p=++cnt;
    tr[p].tg=0;
    if(l==r)
    {
        scanf("%lld",&tr[p].sum);
        return p;
    }
    int mid=l+r>>1;
    tr[p].l=build(l,mid);
    tr[p].r=build(mid+1,r);
    tr[p].sum=tr[tr[p].l].sum+tr[tr[p].r].sum;
    return p;
}
int update(int pre,int pl,int pr,int l,int r,int val)
{
    int p=++cnt;
    tr[p]=tr[pre];
    tr[p].sum+=(r-l+1)*val;
    if(l==pl&&r==pr)
    {
        tr[p].tg+=val;//标记用来查询子区间
        return p;
    }
    int mid=pl+pr>>1;
    if(r<=mid)tr[p].l=update(tr[pre].l,pl,mid,l,r,val);
    else if(l>mid)tr[p].r=update(tr[pre].r,mid+1,pr,l,r,val);
    else
    {
        tr[p].l=update(tr[pre].l,pl,mid,l,mid,val);
        tr[p].r=update(tr[pre].r,mid+1,pr,mid+1,r,val);
    }
    return p;
}
ll query(int t,int pl,int pr,int l,int r)
{
    if(l==pl&&r==pr)return tr[t].sum;
    ll res=1ll*(r-l+1)*tr[t].tg;
    int mid=pl+pr>>1;
    if(r<=mid)return query(tr[t].l,pl,mid,l,r)+res;
    else if(l>mid)return query(tr[t].r,mid+1,pr,l,r)+res;
    else return query(tr[t].l,pl,mid,l,mid)+query(tr[t].r,mid+1,pr,mid+1,r)+res;
}
int main()
{
    int n,m;
    cin>>n>>m;
    cnt=0,now=0;
    root[0]=build(1,n);
    char c[3];
    int l,r,t,x;
    while(m--)
    {
        scanf("%s",c);
        if(c[0]=='Q')
        {
            scanf("%d %d",&l,&r);
            printf("%lld\n",query(root[now],1,n,l,r));
        }
        else if(c[0]=='H')
        {
            scanf("%d %d %d",&l,&r,&t);
            printf("%lld\n",query(root[t],1,n,l,r));
        }
        else if(c[0]=='C')
        {
            scanf("%d %d %lld",&l,&r,&x);
            root[now+1]=update(root[now],1,n,l,r,x);
            now++;
        }
        else
        {
            scanf("%d",&t);
            now=t;
        }
    }
    return 0;
}
```

# 树的重心

定义：树的重心：重心是指树中的一个结点，如果将这个点删除后，剩余各个连通块中点数的最大值最小，那么这个点就是这棵树的重心。

用数组d存储以该节点为根的子树的节点数，则遍历每个节点时可以求出每个儿子节点的节点数，取出上述数的最大值，用总结点数减去上述数求和再减一就是最后一个连通块的节点数，取max即可

下面的代码输出了可能为树的重心的节点并从小到大输出

```c++
#include<iostream>
#include<algorithm>
#include<cstring>

using namespace std;
const int N=5e4+10;
int h[N],e[N<<1],ne[N<<1],idx;
void init()
{
    memset(h,-1,sizeof(h));
}
void add(int a,int b)
{
    e[idx]=b,ne[idx]=h[a],h[a]=idx++;
}
int n;
int d[N],ans[N],num=0,maxnum=1e9;
void dfs(int u,int fa)
{
    d[u]=1;
    int tmp=0;
    for(int i=h[u];~i;i=ne[i])
    {
        int v=e[i];
        if(v==fa)continue;
        dfs(v,u);
        d[u]+=d[v];
        // printf("%d %d %d %d\n",u,v,d[u],d[v]);
        tmp=max(tmp,d[v]);
    }
    tmp=max(tmp,n-d[u]);
    // if(u==2||u==3)printf("%d %d\n",u,tmp);
    if(tmp<maxnum)
    {
        maxnum=tmp;
        num=0;
        ans[++num]=u;
    }
    else if(tmp==maxnum)ans[++num]=u;
}
int main()
{
    init();
    cin>>n;
    for(int i=1;i<n;i++)
    {
        int u,v;
        cin>>u>>v;
        add(u,v),add(v,u);
    }
    dfs(1,0);
    sort(ans+1,ans+1+num);
    // cout<<d[1]<<endl;
    for(int i=1;i<=num;i++)printf("%d ",ans[i]);
    return 0;
}
```

# LCA

基于倍增法的LCA
定义

$f[x][i]$为$x$节点的第$2^i$个祖先，$f[x][0]$为$x$的父节点
则有递推关系
$f[x][i]=f[f[x][i-1]][i-1]$

下面代码输入两个节点输出他们的最近公共祖先

```c++
#include<iostream>
#include<cstring>
#include<algorithm>

using namespace std;
const int N=5e5+10;
int h[N],e[N<<1],ne[N<<1],idx;
int f[N][20],deep[N];
void add(int a,int b)
{
    e[idx]=b,ne[idx]=h[a],h[a]=idx++;
} 
void init()
{
    memset(h,-1,sizeof h);
    idx=0;
}
void dfs(int x,int fa)
{
    deep[x]=deep[fa]+1;
    f[x][0]=fa;
    for(int i=1;(1<<i)<=deep[x];i++)
        f[x][i]=f[f[x][i-1]][i-1];
    for(int i=h[x];~i;i=ne[i])
    {
        if(e[i]!=fa)
            dfs(e[i],x);
    }
}
int LCA(int x,int y)
{
    if(deep[x]<deep[y])swap(x,y);
    for(int i=19;i>=0;i--)
        if(deep[x]-(1<<i)>=deep[y])
            x=f[x][i];
    if(x==y)return y;
    for(int i=19;i>=0;i--)
    {
        if(f[x][i]!=f[y][i])
        {
            x=f[x][i],y=f[y][i];
        }
    }
    return f[x][0];
}
int main()
{
    init();
    int n,m,root;
    cin>>n>>m>>root;
    for(int i=1;i<n;i++)
    {
        int u,v;
        cin>>u>>v;
        add(u,v),add(v,u);
    }
    dfs(root,0);
    while(m--)
    {
        int x,y;
        cin>>x>>y;
        cout<<LCA(x,y)<<endl;
    }
    return 0;
}
```

## 树上差分



# 并查集

```cpp
const int N = 2e5 + 9;
int s[N]; // 集
int rank[N]; // 权值，记录当前节点到根节点的距离

int ans;

void init_set() {
    for(int i = 0; i <= N; ++i) {
        s[i] = i;
        rank[i] = 0;
    }
}

int find_set(int x) {
    if(x != s[x]) {
        int t = s[x];
        s[x] = find_set(s[x]); // 路径压缩
        rank[x] += rank[t];
    }
    return s[x];
}

void merge_set(int a, int b, int v) {
    int root_a = find_set(a);
    int root_b = find_set(b);
    if(root_a == root_b) {
        if(rank[a] - rank[b] != v) {
            ++ans;
        }
    } else {
        s[root_a] = root_b; // 合并
        rank[root_a] = rank[b] - rank[a] + v;
    }
}
```

# 离散化结构

```cpp
struct data {
    int val; // 值
    int id; // 位置

    bool operator<(const data& other) {
        return this->val < other.val;
    }
};
```

# 负进制

例如-15 的-2进制为110001//8+4+2+1//1111

解答步骤：

-15 /-2 = 8……1

8 /-2 = -4……0

-4/-2=2……0

2/-2=-1……0

-1/-2=1……1

1/-2=0……1

对于第一项-15/-2为什么不能为7……-1，**因为余数不能为负数，但是在计算机中结果是这样的：-15%-2 = -1,-15/-2 = 7**，不满足运算规则。我们只需要将商+1，余数-除数即可，因为余数（绝对值）一定小于除数，所以这样就可以将余数装换为正数。

商\*除数+余数=被除数

商\*除数+除数+余数-除数=被除数

(商+1）\*除数+（余数-除数）=被除数

7*(-2)-1 = -15

(7+1)*(-2)+1 = -15

对于原本余数是正数的不能使用，此式子会改变商的结果和余数结果，商结果为商+1，

余数结果为余数-除数

[P1017 [NOIP2000 提高组\] 进制转换 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1017)

```
输入格式

第一个是十进制数 n。第二个是负进制数的基数 𝑅。

输出格式

输出此负进制数及其基数，若此基数超过 10，则参照 16 进制的方式处理。
```

```c++
#include <bits/stdc++.h>
using namespace  std;
char a[]= {'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T'
			,'U','V','W','X','Y','Z'};
int main ()
{
	int n;
	cin >>n;
	int chushu,shang,yushu;
	int r;
	cin >> r;
	chushu = n;
	shang = 1;
	char b[100000];
	int i = 0;
	while(shang !=0)
	{
		
		shang = chushu / r;
		yushu = chushu % r;
		if(yushu < 0 )//余数小于0，改变商和余数的值。
		{
			shang++;
			yushu=yushu-r;
		}
		if(yushu >= 10)
			b[i] = a[yushu-10];
		else
			b[i] = yushu+'0';
		i++;
		chushu = shang;
	}
	cout<<n<<"=";
	for(int j = i - 1;j >=0;j--)
	{
		
		cout<<b[j];
	}
	cout<<"(base"<<r<<")";
	return 0;
}

```

# 高精度

### 高精度加法

传入参数约定：传入参数均为string类型，返回值为string类型

算法思想：倒置相加再还原。

```c++
string add(string a,string b)//只限两个非负整数相加
{
    const int L=1e5;
    string ans;
    int na[L]={0},nb[L]={0};
    int la=a.size(),lb=b.size();
    for(int i=0;i<la;i++) na[la-1-i]=a[i]-'0';
    for(int i=0;i<lb;i++) nb[lb-1-i]=b[i]-'0';
    int lmax=la>lb?la:lb;
    for(int i=0;i<lmax;i++) na[i]+=nb[i],na[i+1]+=na[i]/10,na[i]%=10;
    if(na[lmax]) lmax++;
    for(int i=lmax-1;i>=0;i--) ans+=na[i]+'0';
    return ans;
}
```

### 高精度减法

传入参数约定：传入参数均为string类型，返回值为string类型

算法思想：倒置相减再还原。

```c++
string sub(string a,string b)//只限大的非负整数减小的非负整数
{
    const int L=1e5;
    string ans;
    int na[L]={0},nb[L]={0};
    int la=a.size(),lb=b.size();
    for(int i=0;i<la;i++) na[la-1-i]=a[i]-'0';
    for(int i=0;i<lb;i++) nb[lb-1-i]=b[i]-'0';
    int lmax=la>lb?la:lb;
    for(int i=0;i<lmax;i++)
    {
        na[i]-=nb[i];
        if(na[i]<0) na[i]+=10,na[i+1]--;
    }
    while(!na[--lmax]&&lmax>0)  ;lmax++;
    for(int i=lmax-1;i>=0;i--) ans+=na[i]+'0';
    return ans;
}
```



### 高精度乘法

1）高精度乘高精度的朴素算法

1）高精度乘高精度的朴素算法

 

传入参数约定：传入参数均为string类型，返回值为string类型

算法思想：倒置相乘，然后统一处理进位，再还原。

```c++
string mul(string a,string b)//高精度乘法a,b,均为非负整数
{
    const int L=1e5;
    string s;
    int na[L],nb[L],nc[L],La=a.size(),Lb=b.size();//na存储被乘数，nb存储乘数，nc存储积
    fill(na,na+L,0);fill(nb,nb+L,0);fill(nc,nc+L,0);//将na,nb,nc都置为0
    for(int i=La-1;i>=0;i--) na[La-i]=a[i]-'0';//将字符串表示的大整形数转成i整形数组表示的大整形数
    for(int i=Lb-1;i>=0;i--) nb[Lb-i]=b[i]-'0';
    for(int i=1;i<=La;i++)
        for(int j=1;j<=Lb;j++)
        nc[i+j-1]+=na[i]*nb[j];//a的第i位乘以b的第j位为积的第i+j-1位（先不考虑进位）
    for(int i=1;i<=La+Lb;i++)
        nc[i+1]+=nc[i]/10,nc[i]%=10;//统一处理进位
    if(nc[La+Lb]) s+=nc[La+Lb]+'0';//判断第i+j位上的数字是不是0
    for(int i=La+Lb-1;i>=1;i--)
        s+=nc[i]+'0';//将整形数组转成字符串
    return s;
}
```

### 高精度除法

高精度除单精度

传入参数约定：传入第一参数为string类型，第二个为int型，返回值为string类型

算法思想：[模拟](https://www.baidu.com/s?wd=模拟&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd)手工除法。

```c++
string div(string a,int b)//高精度a除以单精度b
{
    string r,ans;
    int d=0;
    if(a=="0") return a;//特判
    for(int i=0;i<a.size();i++)
    {
            r+=(d*10+a[i]-'0')/b+'0';//求出商
            d=(d*10+(a[i]-'0'))%b;//求出余数
    }
    int p=0;
    for(int i=0;i<r.size();i++)
    if(r[i]!='0') {p=i;break;}
    return r.substr(p);
}
```

### 高精度取模

```c++
string div(string a,int b)//高精度a除以单精度b
{
    string r,ans;
    int d=0;
    if(a=="0") return a;//特判
    for(int i=0;i<a.size();i++)
    {
            r+=(d*10+a[i]-'0')/b+'0';//求出商
            d=(d*10+(a[i]-'0'))%b;//求出余数
    }
    int p=0;
    for(int i=0;i<r.size();i++)
    if(r[i]!='0') {p=i;break;}
    return r.substr(p);
}
```

### 高精度阶乘

传入参数约定：传入参数为int型，返回值为string类型

算法思想：高精度乘单精度的简单运用。

```c++
string fac(int n)
{
    const int L=100005;
    int a[L];
    string ans;
    if(n==0) return "1";
    fill(a,a+L,0);
    int s=0,m=n;
    while(m) a[++s]=m%10,m/=10;
    for(int i=n-1;i>=2;i--)
    {
        int w=0;
        for(int j=1;j<=s;j++) a[j]=a[j]*i+w,w=a[j]/10,a[j]=a[j]%10;
        while(w) a[++s]=w%10,w/=10;
    }
    while(!a[s]) s--;
    while(s>=1) ans+=a[s--]+'0';
    return ans;
}
```

# 字符串

## 进制哈希

### BKDRHash

设定一个进制P，需要计算一个字符串的哈希值，把每个字符看作每个进制位上的一个数字，这个串转换为一个基于进制P，的数，最后对M取余数，就得到了这个字符串的哈希值。

进制P常用的值有31、131、1313、13131、131313。用这些数值能有效避免碰撞。

洛谷P3370(set<stirng>)

如题，给定 N个字符串（第 i个字符串长度为 $M_i$，字符串内包含数字、大小写字母，请求出 N个字符串中共有多少个不同的字符串。

```c++
#include <bits/stdc++.h>
using namespace std;
#define ull unsigned long long
ull a[10010];
char s[10010];
ull BKDRHash(char *s)
{
	ull P = 131,H = 0;
	int n = strlen(s);
	for(int i = 0;i < n;i++)
	{
		H = H * P + s[i] - 'a' + 1;
	}
	return H;
}
int main ()
{
	int n;
	cin>>n;
	for(int i  = 0;i < n;i++)
	{
		cin>>s;
		a[i] = BKDRHash(s);
	}
	int ans = 0;
	sort(a, a+n);
	for(int i = 0;i < n;i++)
	{
		if(a[i] != a[i+1])
			ans++;
	}
	cout<<ans;
}
```

字符串的各种操作对应的哈希计算都能按P进制数的运算规则进行。设字符串S的哈希值为$H(S)$，长度为$len(S)$。以两个字符串的组合为例，两个字符串组合$S_1+S_2$的哈希值为$H(S)*P^{len(S_2)}+H(S_2)$。其中乘以$P^{len(S_2)}$相当于左移了$len(S_2)$位。

例如，$S_1=$"abc",$S_2=$"xy"，$S_1+S_2=$"abcxy"的哈希值等于$H(abc)*P^2+H(xy)$。

利用进制哈希可以按进制做算数运算的特折来快速计算S的前缀。例如,$S = $"abcdefg"，它的前缀有$\{a,ab,abc,abcd,……\}$。

首先计算前缀a，得到$H(a)$，然后前缀ab，$H(ab) = H(a)*P+H(b)$，前缀abc，$H(abc) = H(ab) * P+H(c)$。

查询任意子串哈希值，$H(de) = H(abcde)-H(abc) * P^2$。

求区间[L,R]的哈希值

```c++
ull get_hash(ull L,ull R)
{
	return H[R] - H[L - 1] * P[R-L+1];
}
```

## Manacher

对于字符串$abababacababacd$取中心点c，得到其最大回文串为$$

对于字符串$abababacababacd$取中心点c，得到其最大回文串为$$

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 11000002;
int n,P[N<<1];//以S[i]为中心的会问班级
char a[N],S[N<<1];
void change()
{
	n = strlen(a);
	int k = 0;
	S[k++] = '$';
	S[k++] = '#';
	for(int i = 0;i < n;i++)
	{
		S[k++] = a[i];
		S[k++] = '#';
	}
	S[k++] = '&';
	n = k;
}
void manacher()
{
	int R =0,C;//R为对应回文串的最大右端点
	for(int i = 1;i < n;i++)
	{
		if(i < R)
			P[i] = min(P[(C<<1) - i],P[C] + C - i);//合并处理两种情况
		else
			P[i] = 1;
		while(S[i + P[i]] == S[i - P[i]])//中心扩展
			P[i]++;
		if(P[i] + i >R)
		{
			R = P[i] + i;//更行最大R
			C = i;
		}
	}
}
int main ()
{
	cin>>a;
	change();
	manacher();
	int ans = 1;
	for(int i = 0;i < n;i++)
	{
		ans = max(ans,P[i]);
	}
	cout<<ans - 1;
	return 0;
}
```

## KMP

```cpp
/**
 * 获取next数组
 * @par t 模式串
 * @return next数组
 */
std::vector<int> get_next(const std::string& t) {
    int m = t.size();
    std::vector<int> next(m, 0);
    int j = 0;  // j为模式串中已匹配的前缀长度
    for (int i = 1; i < m; ++i) {
        while (j > 0 && t[i] != t[j]) {
            j = next[j - 1];
        }
        if (t[i] == t[j]) {
            ++j;
        }
        next[i] = j;
    }
    return next;
}

/**
 * tmp算法匹配模式串
 * @par s 文本串
 * @par t 模式串
 * @return t在s中出现的所有位置（起始索引），若不存在，则返回空列表
 */
std::vector<int> kmp(const std::string& s, const std::string& t) {
    std::vector<int> res;
    std::vector<int> next = get_next(t);
    int n = s.size(), m = t.size();
    int j = 0;  // j为模式串中已匹配的前缀长度
    for (int i = 0; i < n; ++i) {
        while (j > 0 && s[i] != t[j]) {
            j = next[j - 1];
        }
        if (s[i] == t[j]) {
            ++j;
        }
        // 模式串匹配完
        if (j == m) {
            res.push_back(i - m + 1);
            j = next[j - 1];
        }
    }
    return res;
}
```

## 字典树

```cpp
const int N = 8e5 + 3;

struct node {
    int cnt; // 这个前缀出现的次数
    int son[26]; // 26个字母，26个儿子
    bool repeat; // 这个前缀是否重复
    node() {
        cnt = 0;
        memset(son, false, sizeof son);
        repeat = false;
    }
} trie[N];

int num = 0;

/**
 * 插入字符串
 * @par str 带插入的字符串
 */
void insert(char* s) {
    int v, len = strlen(s);
    int u = 0;
    for (int i = 0; i < len; i++) {
        v = s[i] - 'a';
        if (!trie[u].son[v]) {
            trie[u].son[v] = ++num;
        }
        u = trie[u].son[v];
    }
    trie[u].repeat = 1;
}

/**
 * 查询字符串
 * @par 待查询的字符串
 * @return 1=存在 2=重复 3=不存在
 */
int find(char* s) {
    int v, u = 0, len = strlen(s);
    for (int i = 0; i < len; i++) {
        v = s[i] - 'a';
        if (!trie[u].son[v]) {
            return 3;
        }
        u = trie[u].son[v];
    }
    if (!trie[u].repeat) {
        return 3;
    }
    if (!trie[u].cnt) {
        trie[u].cnt++;
        return 1;
    }
    return 2;
}
```

## 后缀数组

求解单模匹配问题

#### 倍增法计算后缀数组

```cpp
const int N = 2e5 + 5; // 字符串的长度

int sa[N], rk[N], tmp[N + 1];
int k, n;

/**
 * 组合数有两部分
 * 高位是rk[i]，低位是rk[i + k]
 */
auto comp_sa = [&](int i, int j) -> bool {
    if(rk[i] != rk[j]) {
        return rk[i] < rk[j];
    } else {
        int ri = i + k <= n ? rk[i + k] : -1;
        int rj = j + k <= n ? rk[j + k] : -1;
        return ri < rj;
    }
};

/**
 * 计算s的后缀数组
 * O(n log n)
 * @par s 文本串
 * @par sa 后缀数组，需要开足够的栈空间
 */
void calc_sa(const std::string& s, int* sa) {
    n = s.length();
    for(int i = 0; i <= n; ++i) {
        rk[i] = s[i];
        sa[i] = i;
    }
    for(k = 1; k <= n; k <<= 1) {
        std::sort(sa, sa + n, comp_sa);
        tmp[sa[0]] = 0;
        for(int i = 0; i < n; ++i) {
            tmp[sa[i + 1]] = tmp[sa[i]] + (comp_sa(sa[i], sa[i + 1]) ? 1 : 0);
        }
        for(int i = 0; i < n; ++i) {
            rk[i] = tmp[i];
        }
    }
}
```

#### 计数排序计算后缀数组

```cpp

```

#### 字符串匹配

```cpp
/**
 * 在s中查找t
 * 时间复杂度 O(m log n)
 * @par s 文本串
 * @par t 模式串
 * @par sa 后缀数组
 * @return 返回t在s中的位置 
 */
int find(const std::string& s, const std::string& t, int* sa) {
    int i = 0, j = s.length();
    while(j - i > 1) {
        int k = i + ((j - i) >> 1);
        if(s.compare(sa[k], t.length(), t) < 0) {
            i = k;
        } else {
            j = k;
        }
    }

    if(s.compare(sa[j], t.length(), t) == 0) {
        return sa[j];
    }
    if(s.compare(sa[i], t.length(), t) == 0) {
        return sa[i];
    }
    return -1; // 没找到
}
```



# 图论 // TODO 重写

## 图论基本算法

### 链式前向星建图

```cpp
const int N = 1e5 + 3;

struct Edge {
    int to, next, weight;
} edge[N << 1];

int head[N], cnt;

/**
 * 初始化图
 */
void init() {
    for(auto& h : head) {
        h = -1;
    }
    for(auto& e : edge) {
        e.next = -1;
    }
    cnt = 0;
}

/**
 * 添加边
 * @par from 起点
 * @par to 终点
 * @par weight 边权
 */
void add_edge(int from, int to, int weight) {
    edge[cnt].to = to;
    edge[cnt].weight = weight;
    edge[cnt].next = head[from];
    head[from] = cnt++;
}

/**
 * 遍历cur的邻接结点
 * @par cur 当前节点
 * @par func 对邻接结点的操作逻辑，参数为邻接节点的索引
 * @brief 可以使用以下代码遍历邻接节点
 *      for_each(cur, [&](int i) {
 *          int neighbor = edge[i].to;
 *          int weight = edge[i].weight;
 *          ...
 *      })
 */
void for_each(int cur, const std::function<void(int)>& func) {
    for(int i = head[cur]; ~i; i = edge[i].next) {
        func(i);
    }
}
```

### dfs

```cpp
bool vis[N];

static void init_vis() {
    memset(vis, 0, sizeof vis);
}

static void dfs_algorithm(int u, const std::function<void(int)>& func) {
    func(u);
    vis[u] = true;
    for_each(u, [&](int i) {
        int to = edge[i].to;
        if (!vis[to]) {
            dfs_algorithm(to, func);
        }
    });
}

void dfs(int u, const std::function<void(int)>& func) {
    init_vis();
    dfs_algorithm(u, func);
}
```

### bfs

```cpp
void bfs(int u, const std::function<void(int)>& func) {
    init_vis();
    std::queue<int> q;
    vis[u] = true;
    q.push(u);
    while (!q.empty()) {
        int k = q.front();
        q.pop();
        func(k);
        for_each(k, [&](int i) {
            int to = edge[i].to;
            if (!vis[to]) {
                q.push(to);
                vis[to] = true;
            }
        });
    }
}
```

### SPFA

```cpp
/**
 * SPFA算法求最短路径
 * @par s 起点
 * @par t 终点
 * @return 最短路径权重
 */
int SPFA(int s, int t) {
    int dist[N];
    std::queue<int> q;

    init_vis();
    std::fill(dist, dist + N, INF);

    q.push(s);
    vis[s] = true;
    dist[s] = 0;

    while (!q.empty()) {
        int cur = q.front();
        q.pop();
        vis[cur] = false;

        for_each(cur, [&](int i) {
            int to = edge[i].to;
            int w = edge[i].w;
            if (dist[to] > dist[cur] + w) {
                dist[to] = dist[cur] + w;
                if (!vis[to]) {
                    q.push(to);
                    vis[to] = true;
                }
            }
        });
    }
    return dist[t];
}
```

### SPFA SLF优化

```cpp
int SPFA_SLF(int s, int t) {
    int dist[N];
    std::deque<int> dq;

    init_vis();
    std::fill(dist, dist + N, INF);

    dq.push_back(s);
    vis[s] = true;
    dist[s] = 0;

    while (!dq.empty()) {
        int cur = dq.front();
        dq.pop_front();
        vis[cur] = false;

        for_each(cur, [&](int i) {
            int to = edge[i].to;
            int w = edge[i].w;
            if (dist[to] > dist[cur] + w) {
                dist[to] = dist[cur] + w;
                if (!vis[to]) {
                    vis[to] = true;
                    if (dq.size() && dist[to] >= dist[dq.front()]) {
                        dq.push_back(to);
                    } else {
                        dq.push_front(to);
                    }
                }
            }
        });
    }

    return dist[t];
}
```

## 基环树

基环树中寻找最长链状采用dfs

例如2->3->4->3

此时一条路径2343为最长路径，之后dir[3]dir[4]为1不会搜索，因为他们一定没有dir[2]最长。

那么如果从dir[3]开始，dir[4]也不会搜索了。因此2是进入链的方向，一旦有1条组成的环，环内的数都不用搜索了。

```cpp
int a[N];
int dir[N],s[N];
void dfs(int x,int sum)
{
	if(s[x] = 1)//路径重复
	{
		ans = max(ans, sum);
		return;
	}
	dir[x] = 1;//剪枝，标记此点已经搜索过了
	s[x] = 1;//标记此点在线路上
	dfs(s[x],sum+1)
	s[x] = 0;//搜索完毕路径标记还原
}
int main()
{
	int n,i;
	cin<<n;
	for(i = 1;i<= n;i++)
	{
		int t;
		cin>>t;
		a[i] = t;
	}
	for(i = 1;i <= n;i++)
	{
		while(!dir[x])
		{
			dfs(i,0)//从第一个点开始搜索
		}
	}
}
```

## 树链剖分求LCA

```cpp
class HLD {
public:
    HLD(int n) {
        this->n = n;
        matrix.resize(n + 1);
        size.resize(n + 1);
        depth.resize(n + 1);
        top.resize(n + 1);
        son.resize(n + 1);
        parent.resize(n + 1);
    }

    /**
     * 添加双向边
     * @par from 起点
     * @par to 终点
     */
    void add_edge(int from, int to) {
        matrix[from].push_back(to);
        matrix[to].push_back(from);
    }

    /**
     * 遍历cur的邻接结点
     * @par cur 当前节点
     * @par func 对邻接结点执行的逻辑
     * 
     * func
     * @par 邻接结点
     */
    void for_each(int cur, const std::function<void(int)>& func) {
        for(auto& n : matrix[cur]) {
            func(n);
        }
    }

    /**
     * 初始化
     * O(n)
     * @par root 根节点
     */
    void init(int root = 1) {
        dfs1(root);
        dfs2(root, root);
    }

    /**
     * 求解lca
     * O(log n)
     * @par x 节点x
     * @par y 节点y
     * @return 返回节点x和节点y的LCA节点
     */
    int lca(int x, int y) {
        while(top[x] != top[y]) {
            if(depth[top[x]] > depth[top[y]]) {
                x = parent[top[x]];
            } else {
                y = parent[top[y]];
            }
        }
        return depth[x] < depth[y] ? x : y;
    }

    /**
     * 查询两点间的距离
     * @par x 节点x
     * @par y 节点y
     * @return 两点间的距离
     */
    int distance(int x, int y) {
        return depth[x] + depth[y] - (depth[lca(x, y)] << 1);
    }

private:
    int n; // 节点个数
    std::vector<std::vector<int>> matrix; // 邻接矩阵
    std::vector<int> size; // size[i] = j：表示i节点的子树大小为j
    std::vector<int> depth; // depth[i] = j：表示i节点的深度为j
    std::vector<int> top; // top[i] = j：表示i节点所在的重链头部为j
    std::vector<int> son; // son[i] = j：表示i节点的重儿子为j
    std::vector<int> parent; // father[i] = j：表示i节点的父节点为j

    /**
     * 第一次dfs
     * @par cur 当前节点
     */
    void dfs1(int cur) {
        size[cur] = 1;
        depth[cur] = depth[parent[cur]] + 1;
        for_each(cur, [&](int neighbor) {
            if(neighbor == parent[cur]) {
                return; // continue
            }

            parent[neighbor] = cur;
            dfs1(neighbor);
            // 更新当前节点的子树大小
            size[cur] += size[neighbor];
            // 寻找重儿子
            if(size[neighbor] > size[son[cur]]) {
                son[cur] = neighbor;
            }
        });
    }

    /**
     * 第二次dfs
     * @par cur 当前节点
     * @par up 当前节点的重链头部
     */
    void dfs2(int cur, int up) {
        top[cur] = up;
        if(son[cur]) {
            dfs2(son[cur], up);
        }
        for_each(cur, [&](int neighbor) {
            if(neighbor == parent[cur] || neighbor == son[cur]) {
                return; // continue
            }
            dfs2(neighbor, neighbor);
        });
    }
};
```



# 数论

## 模运算

取模运算为求a除以m的余数，记为$a\mod\ m = a \% m$。

C及Java取模运算规则：$5 \% 3 = 2，(-5)\%(-3)= -2，5\%(-3) = 2，(-5)\% 3 = -2$

先按正整数取余，然后加上符号，符号与被除数保持一致。

性质：

1. $( a + b ) \mod m = ( (a \mod m) + (b \mod m) ) \mod m$如果没有限制ab正负，C代码中左右可能符号相反、大小相差m。

2. $( a - b ) \mod m = ( (a \mod m) - (b \mod m) ) \mod m$如果没有限制ab正负，C代码中左右可能符号相反、大小相差m。

3. $( a * b )\mod m = ( (a \mod m) * (b \mod m) ) \mod m$。

4. 对于除法是错误的。

对于乘法的大数取模，直接用a*b会溢出， $(a \mod m) * (b \mod m)$也可能溢出。此时需要这样避免。

$a * b$改成$(a * 2 * 2 * 2 * 2 * 2) * (b\div2\div2\div2\div2\div2)$。如果b是奇数变成$(a * 2) * (b\div 2 + 1) = (a * 2) * (b\div 2) + (a * 2)$

如果m比a大，mul函数仍会出错。

```c++
long long mul (long long a,long long b, long long m)
{
	a = a % m;
	b = b % m;
	long long res = 0;
	while(b > 0)
	{
		if(b & 1)//判断奇偶
			res = (res + a) % m;
		a = (a + a) % m;
		b >>=1;
	}
	return res;
}
int main()
{
	long long a;
	long long b;
	long long m;
	cout<<mul(a, b, m);
}
```

## 快速幂

$a^{11} = a^8+a^2+a^1; 11 ={011_2}=2^3+2^1+2^0 = 8+ 2+ 1 $

```c++
long long fastpow(long long a,long long b,long long mod)
{
    long long ans = 1;
    a = a % mod;
    while(b)
    {
        if(b & 1)
        	ans = ans * a % mod;//要乘
   		a = a * a % mod;//递推2 4 8 16
    	b = b >> 1;//进位
    }
    return ans;
}
```

## 矩阵

矩阵乘法

$A = m * n , B = n * u,C =AB= m*u$

```c++
for(int i = 1;i <= m;i++)
    for(int j = 1;j <= u;j++)
        for(int k = 1;k <= n;k++)
            c[i][j] +=a[i][k] * b[k][j];
```

矩阵快速幂

```c++
struct matrix
{
	int m[N][N];
};
matrix operator * (const matrix &a,const matrix & b)//重载*为矩阵相乘
{
	matrix c;
	memset(c.m, 0, sizeof(c.m));
	for(int i = 0;i < N;i++)
		for(int j = 0;j < N;j++)
			for(int k = 0;k < N;k++)
				//c.m[i][j] += a.m[i][k] * b.m[k][j];
				c.m[i][j] = (c.m[i][j] + a.m[i][k] * b.m[k][j]) % mod;
	return c;
}
matrix pow_matrix(matrix a,int n)
{
	matrix ans;
	memset(ans.m, 0, sizeof(ans.m));//单位矩阵
	for(int i = 0;i < N;i++)
	{
		ans.m[i][i] = 1;
	}
	while(n)
	{
		if(n&1)
			ans = ans * a;
		a = a * a;
		n >>= 1;
	}
	return ans;
}
```

## GCD与LCM

### GCD

$gcd(a,b) = gcd(|a|,|b|)$。因为$-a$的因子与$a$相同,所以$gcd(a,b) = gcd(|a|,|b|)$

互素:$gcd(a,b) = 1$;

GCD性质

1.$gcd(a,b) = gcd(a, a+b) = gcd(a,k*a+b)$

2.$gcd(ka,kb) = k * gcd(a,b)$

3.定义多个整数的GCD：$gcd(a,b,c) = gcd[gcd(a,b),c]$

4.若$gcd(a,b) = d$，则$gcd(a/d,b/d) = 1$,即$a/d$与$b/d$互素

5.$gcd(a+cd,b) = gcd(a,b)$

#### 欧几里得算法

$gcd(a,b) = gcd(b,a \% b)$

```c++
int mygcd(int a, int b)
{
	return b ? gcd(b,a%b): a;
}
```

此算法要做取模，高精度除法取模耗时，可以采用以下算法。

#### 更相减损术

$gcd(a,b) = gcd(b,b -a)=gcd(a,a-b)$

```c++
int mygcd(int a, int b)
{
    while(a != b)
    {
        if(a > n)
            a = a - b;
        else
            b = b - a;
    }
    return a;
}
```

#### Stein算法

(1)a和b都是偶数。$gcd(a,b) = 2gcd(a/2,b/2)$

(2)a奇b偶数（a偶b奇）。若k与y互为质数，有$gcd(kx,y) = gcd(x,b)$。当k  = 2，b为奇数时，有$gcd(a,b) = gcd(a/2,b)$。

(3)a和b都是奇数。$gcd(a,b) = gcd((a+b)/2,(a-b)/2)$

```c++
int stein(int a,int b)
{
	if(a < b)
	{
		a^=b;
		b^=a;
		a^=b;
	}
	if(b==0)
		return a;
	if( (!(a&1)) && (!(b&1)) )
		return stein(a>>1,b>>1) << 1;
	else if( (a&1) && (!(b&1)) )
		return stein(a,b>>1);
	else if(!(a&1)) && (b&1) )
		return stein(a>>1,b);
	else
		return stein(a-b,b);
}
```

### LCM

$gcd(a,b)lcm(a,b)=ab$,即$lcm(a,b) = ab/gcd(a,b) = a/gcd(a,b)b$

先除后乘

```c++
int lcm(int a,int b)
{
	return a / gcd(a,b) * b;
}
```



#### 裴蜀定理

如果a与b均为整数，则有整数x和y使$ax+by=gcd(a,b)$。

##### 洛谷P4549 

```c++
#include <iostream>
using namespace std;
int a[100003];
long long gcd(int a,int b)
{
    return b ? gcd(b,a%b):a;
}
int main ()
{
    int n;
    int i;
    cin>>n;
    for(i = 0;i < n;i++)
    {
        cin>>a[i];
    }
    long long sum = 0;
    sum = gcd(abs(a[0]),abs(a[1]));
    for(i = 1;i < n;i++)
    {
        sum = gcd(abs(a[i]),sum);
    }
    cout<<sum;
}
```



## 线性丢番图方程

方程$ax + by = c$成为二元性丢番图方程，如果直线上有整数坐标点，就有解，没有则无解，如果存在一个解就有无数个解。

设a，b为整数且$gcd(a，b) = d$。如果d不能整除c，那么方程$ax + by = c$没有整数，否则存在无穷多个解。如果（${x_0}$，${y_0}$）是方程的一个特解，那么所有解可以表示为$x = {x_0}+\frac{b}{d}*n$，$y = {y_0}-\frac{a}{d}*n$,n为任意整数。

### 扩展欧几里得求特解

迭代时$gcd(a,0) = a$   $ax + 0y = gcd(a,0) = a$此时有特解$x = 1,y = 0$。

$gcd(a,b) = gcd(b,a\%b)$。$ax + by = gcd(a,b)$。

$ax + by = bx'+a\%by' = bx'+[a-b(a/b)]y' = bx' + ay' - b(a/b)y' = ay'+b[x'-(a/b)y']$

$ \begin{cases}x = y' \\y = x'-(\frac{a}{b})y\end{cases} $

使用欧几里得求$ax + by = gcd(a,b)$的一个特解之后，可以求$ax + by = c$的一个通解。

记$d = gcd(a,b)$，此时$gcd(a,b)$能整除$c$。欧几里得求出的特解为$(x_0,y_0)$。tyjk./

在$ax_0+by_0 = d$两边同时乘以$c / d$，得 $ax_0c/d+by_0c/d = c$，此时可以得到$ax + by = c$的一个解为$(x_0',y_0')$。

即$x_0=x_0c/d ，y_0 = y_0c/d$。故通解为$x = x_0'+(b/d)n，y = y_0'-(a/d)n$。

注：欧几里得求出的是$ax + by = gcd(a,b)$的特解。

```c++
long long extend_gcd(long long a, long long b, long long &x,long long &y)//返回gcd(a,b),改变特解x，y
{
	if(b==0)
	{
		x = 1;
		y = 0;
		return 0;
	}
	long long d = extend_gcd(b, a%b, y,x);
	y = y - a / b * x;
	return d;
}
```

求最小解。

已知通解为$x = x_0 + (b/d)n$要使$x$最小，则需要$x_0$不断的减$b/d$。那么此过程相当于取模

公式为$((x_0 \% (b/d)+b/d)\%(b/d))$ 多加一次再去模防止负数。

##### 洛谷P1516

```c++
#include <iostream>

using namespace std;
long long exgcd(long long a,long long b,long long &x,long long &y)
{
    if(b == 0)
    {
        x = 1;
        y = 0;
        return a;
    }
    long long d = exgcd(b,a%b,y,x);
    y -= a/b*x;
    return d;
}
int main () {
    long long x, y, m, n, l;
    cin >> x >> y >> m >> n>>l;
    long long  c = x - y;
    long long a = n - m;
    if (a < 0) {
        a = -a;
        c = -c;
    }
    long long d = exgcd(a, l, x, y);
    if (c % d != 0)
        cout << "Impossible";
    else
        cout << ((x*c/d ) % (l / d) + (l / d)) % (l / d);
}
```

### 多元线性丢番图方程

如果$a_1,a_2,a_3,……,a_n$是非零整数，那么方程$a_1x_1+a_2x_2+……+a_nx_n = c$有整数解，当且仅当$d = gcd(a_1,a_2,……,a_n)$整除$c$，如果方程存在一个解，则方程有无数多个解。

## 同余 

同余定义：设m是正整数，若a和b是整数，且$m \lvert (a - b)$，则称a 和 b 模同余，也就是说 a除以m得到的余数，和b除以m的余数相同；或者说a - b 除以m ，余数为0，因为a和b中间隔了n个m。

同余记作$a \equiv b(\mod m)$,m为同余的模。

例如$7 \lvert(18 - 4)$，所以 $18 \equiv 4(\mod 7)$。

同余的性质

若a和b为整数，m为正整数，则$a \equiv b(\mod m)$当且仅当$a \mod m = b \mod m$。

同余转化为等式。若a 和 b 是整数， 则 $a \equiv b(\mod m)$ 当且仅当 存在整数k，使 $a = b  + km$。

设m是正整数，模m同余的性质

（1）自反性：$a \equiv a(\mod m)$

（2）对称性：$a \equiv b(\mod m)则b \equiv a(\mod m)$

（3）传递性：$a \equiv b(\mod m)，b \equiv c(\mod m)，则a \equiv c(\mod m)$

### 一元线性同余方程

设x是未知数，给定$a、b、m$，求整数x，满足$ax\equiv b(\mod m) $。则有$ax + my = b$，这是二元线性丢番图方程。

所以，求解一元线性同余方程等价于求解二元线性丢番图方程。

### 逆

给定整数a，且满足$gcd(a,m) = 1$，称$ax \equiv 1(\mod m)$的一个解为a模m的逆元，记$a^{-1}$。

例如，$8x \equiv 1(\mod 31)$,有一个解是$x = 4$，4是8模31的逆。所有解，如36、66等也是8模31的逆。

也可以化为$8x + 31y = 1$,$x = 4$是8模31的逆。可以看出m最好是大于a的素数，才能保证$gcd(a,m) = 1$。

#### 求逆

##### 扩展欧几里得求逆

洛谷P1082

```c++
//
// Created by ZA on 2024/8/29.
//
#include <iostream>
using namespace std;
long long excd(long long a,long long b,long long &x,long long &y)
{
    if(b == 0)
    {
         x = 1;
         y = 0;
        return a;
    }
    long long d = excd(b, a%b,y,x);
    y -= a/b*x;
    return d;
}
int main ()
{
    long long a,b;
    long long y,x;
    cin>>a>>b;
    long long d = excd(a,b,x,y);

    cout<<(x % b + b) %b;
}
```

##### 费马小定理

设n是素数，a是正整数且与n互素，有$a^{n-1} \equiv 1(\mod n)$。

$a*a^{n-2} \equiv1(\mod n)$，那么$a^{n-2} \mod n$就是a模n的逆元。

```c++
long long mod_inverse(long long a,long long mod)
{
	return fast_pow(a,mod - 2,mod);
}
```

2024 ICPC 湖北

给定n个整数，求平均值

求n的逆，采用费马最小定理，使用快速幂函数。

```c++
#include <bits/stdc++.h>

using namespace std;
long long m = 998244353;
long long fastpow(long long a,long long b,long long mod)
{
    long long ans = 1;
    a = a % mod;
    while(b)
    {
        if(b & 1)
        	ans = ans * a % mod;//??
   		a = a * a % mod;//??2 4 8 16
    	b = b >> 1;//??
    }
    return ans;
}
long long a[1000003];
int main ()
{
	int n;
	long long sum = 0;
	int i;
	cin>>n;
	for(i = 0;i < n;i++)
	{
		cin>>a[i];
		sum +=a[i];
		sum = sum%m;
	}
	cout<<sum*fastpow(n,m - 2,m)%m;
    return 0;    
}
```



##### 递推求逆

如果要求1~n内所有逆，可以用递推法。复杂度为$\Theta(n)$。

洛谷P3811

给定 n,p 求 1∼n中所有整数在模 p意义下的乘法逆元。

首先$i = 1$的逆是1。

设$p/i = k$，余数是$r$，即$k*i + r \equiv0(\mod p)$，在等式两边乘$i^{-1}*r^{-1}，$得到$k*r^{-1} + i^{-1} \equiv 0(\mod p)$

移项得$i^{-1} \equiv -k*r^{-1}(\mod p)$，即$i^{-1} \equiv -p/i*r^{-1}(\mod p)$，$i^{-1} \equiv (p-p/i)*r^{-1}(\mod p)$。

即$inv[i] = (p-p/i) *inv[p \% i]\%p$。该式子中$-p/i$为负数所以要多加个一个p，并且由于每次操作已经mod p了，所以两式相等。

```cpp
long long inv[N];
void inverse(long long n,long long p)
{
	inv[1] =  1;
	for(int i = 2;i <= N;i++)
	{
		inv[i] = (p - p / i) * inv[p % i] % p;
	}
}
```

#### 用逆解求同余方程

如果有$a$模$m$的一个逆，可以用来求解形如$ax\equiv b (\mod m)$的任何同余方程。

记$a^{-1}$是$a$的一个逆，有$a^{-1}a \equiv 1(\mod m)$。在$ax \equiv b(\mod m)$的两边同时乘以$a^{-1}$，得到$a^{-1}ax \equiv a^{-1}b(\mod m)$，即$x \equiv a^{-1}b(\mod m)$。

例如，为了求出$8x \equiv 22(\mod 31)$的解，可以两边乘以4，4是8模31 的一个逆元，得到$4*8x\equiv 4*22(\mod 31)$，所以$x \equiv 88(\mod 31) \equiv 26(\mod  31)$。

设p是素数，正整数a是其自身模p的逆，当且仅当$a \equiv 1(\mod p)$或$a \equiv -1(\mod p)$。

#### 逆与除法取模

求$(a/b) \mod m$，即a除以b，然后对m取模。这里a和b都是很大的数，如$a = n!$,容易溢出，导致取模错误。用逆可以避免除法计算，设b的逆元是$b^{-1}$，有$(a/b) \mod m =(ab^{-1})\mod m)((bb^{-1}) \mod m) = (a/b*bb^{-1}) \mod m = (bb^{-1}) \ mod m = (ab^{-1}) \mod m$。

除法的模运算转换为乘法模运算。

$(a/b) \mod m = (ab^{-1}) \mod m=(a \mod m)(b^{-1} \mod m) \mod m$。

## 同余方程组

设$m_1，m_2，……，m_r$是两两互素的正整数，则同余方程组$x \equiv a_1 (\mod m_1)，$$x \equiv a_2 (\mod m_2)，$$x \equiv a_3 (\mod m_3)$。

例如，有一个数x，被3除余2，被5除余3，被7除余2，列成同余方程是：$x \equiv 2 (\mod 3)，$$x \equiv 3 (\mod 5)，$$x \equiv 2 (\mod 7)$。

求解结果为$x = 32 + 3*5*7$。

#### 中国剩余定理

设$m_1，m_2,……，m_r$是两两互素的正整数，则同余方程组有整数解，并且模$M=m_1*m_2……*m_r$唯一，解为

$x \equiv (a_1M_1{M_1}^{-1}+a_2M_2{M_2}^{-1}+……+a_rM_r{M_r}^{-1})(\mod M)$其中，$M_i = M/m_i ; {M_i}^{-1}$为$M_i$模$m_i$的逆元。

例如$x \equiv 2 (\mod 3)，$$x \equiv 3 (\mod 5)，$$x \equiv 2 (\mod 7)$      $M = 3*5*7=105$。

$M_1 = 105/3=35$，$M_2 = 105/5=21$，$M_3=105/7=15$。求逆得：${M_1}^{-1}=2,{M_2}^{-1}=1,{M_3}^{-1}=1$。

最后计算$x \equiv 2*35*2+3*21*1+2*15*1 \equiv 233 \equiv 23(\mod 105)$。

#### 迭代法

中国剩余定理的限制条件为两两互素。在不互素中采用迭代法。若x和a是整数，则$x \equiv a(\mod m)$当且仅当存在整数，使$x = a+km$

例如。$x \equiv 2 (\mod 3)，$$x \equiv 3 (\mod 5)，$$x \equiv 2 (\mod 7)$    

（1）把第1个转换为$x = 2+ 3t$，代入第2个当中，$2 + 3t \equiv 3(\mod 5)$。

（2）求解$2+3t \equiv 3(\mod 5)$，即$3t \equiv 1(\mod 5)$，因为$gcd(3,5)$能整除1，所以有解。然后求解$3t \equiv 1(\mod 5)$，先求3模5的逆，结果为2，所以解得$t \equiv 2(\mod 5)$，然后不断转换。

（3）最后合并结果得到，$x \equiv 23(\mod 105)$。

###### 洛谷P4777

给定 $n$ 组非负整数 $a_i, b_i$ ，求解关于 $x$ 的方程组的最小非负整数解。
$$\begin{cases}x\equiv b_1\pmod{a_1}\\x\equiv b_2\pmod{a_2}\\\dots\\x\equiv b_n\pmod{a_n}\end{cases}$$

```c++
#include <bits/stdc++.h>
using namespace std;
long long ai[100010];
long long mi[100010];
int n;
long long mul(long long a,long long b,long long m)
{
	long long res = 0;
	while(b > 0)
	{
		if(b&1)
			res = (res + a) % m;
		a = (a + a)%m;
		b>>=1;
	}
	return res;
}
long long extend_gcd(long long a,long long b,long long &x,long long &y)
{
	if(b == 0)
	{
		x = 1;
		y = 0;
		return a;
	}
	long long d = extend_gcd(b,a%b,y,x);
	y -= a / b * x;
	return d;
}
long long excrt()
{
	long long x,y;
	long long m1 = mi[1],a1 = ai[1];//第一个等式。
	long long ans = 0;
	for(int i = 2;i <= n;i++)
	{
		long long a2 = ai[i],m2 = mi[i];
        long long a = m1,b = m2,c = (a2 - a1 % m2 + m2) % m2;
        long long d = extend_gcd(a,b,x,y);
        if(c%d != 0)//无解
        	return - 1;
        x = mul(x,c/d,b/d);
        ans = a1 + x * m1;
        m1 = m2 / d * m1;
        ans = (ans % m1 + m1) % m1;
        a1 = ans;
	}
	return ans;
}
int main ()
{
	cin>>n;
	for(int i = 1;i <= n;i++)
	{
		cin>>mi[i]>>ai[i];
	}
	cout<<excrt();
}
```

## 素数

### 素数判定

当$n<10^{12}$，采用试除法，大于时，采用Miller_Rabin。

```cpp
bool is_prime(long long n)
{
	if(n <= 1)
		return false;
	for(long long i = 2;i<= sqrt(n);i++)//i*i<=n
	{
		if(n % i ==0)
			return false;
	}
    return true;
}
```

#### 费马素性测试

通过费马小定理的逆定理的几乎成立，可以得出费马素性测试。

为了测试n是否为素数，在1~n任选一个随机的基值a，注意a并不需要与n互素。

（1）如果$a^{n-1}\equiv 1(\mod n)$不成立，那么n肯定不是素数。这实际上是费马小定理的逆否命题。

（2）如果$a^{n-1}\equiv 1(\mod n)$成立，那么n很大概率是素数。尝试的a越多，概率越大。称n是一个基于a的伪素数。

然而并不是完全正确的，有一些合数能被误判通过，不同的a值，被误判的合数不太一样。特别地，有一些合数，不管a选什么，都能通过测试。这种数叫做Carmichael数，前3个Carmichael数是561、1105、1729。不过，Carmichael数数很少，前1亿个正整数中只有255个。

#### Miller-Rabin素性测试

Miller-Rabin素性测试为费马测试排除Carmichael数。

##### 二次探测定理 

如果p是一个奇素数，且$e\geqslant 1$，则方程$x^2 \equiv 1(\mod p^e)$仅有两个解：$x = 1$和$x = -1$。当$e = 1$时，方程$x^2 \equiv 1(\mod p)$仅有两个解$x = 1$和$x = p - 1$。

把$x = 1$和$x = p - 1$称为"x对模p来说1的平凡平方根"。如果对模n存在1的非平凡平方根，则n是合数。

```c++
#include <bits/stdc++.h>

using namespace std;
long long fast_pow(long long x,long long y,int m)
{
	long long res = 1;
	x = x % m;
	while(y)
	{
		if(y&1)
			res = (res * x) % m;
		x = (x * x) % m;
		y >>= 1;
	}
	return res;
}
bool witness(long long a,long long b)//素性测试，返回true表示n是合数
{
	long long u = n - 1;//u是n-1的二进制去掉末尾0
	int t = 0;//n-1的二进制，是奇数u的二进制后面加t个0
	while(u&1 == 0)//整数n-1末尾0的个数就是t
	{
		u = u>>1;
		t++;
	}
	long long x1,x2;
	x1 = fast_pow(a,u,n);
	for(int i = 1;i <= t;i++) //平方取模
	{
		 x2 = fast_pow(x1,2,n);
		 if(x2 == 1&&x1 != 1&&x1 != n-1)
		 {
		 	return true;
		 }
		 x1 = x2;
	}
	if(x1 != -1)
		return true;//用费马测试判断是否为合数
	return false;
}
int miller_rabin(long long n,int s)
{
	if(n < 2)
		return 0;
	if(n == 2)
		return 1;
	if(n%2==0)
		return 0;
	for(int i = 0;i < s &&i < n;i++)//s次测试
	{
		long long a = rand()%(n-1) + 1; //a为随机数
		if(witness(a,n))
			return 0;
	}
	return 1;
}
int main()
{
	int m;
	cin>>m;
	int cnt = 0;
	for(int i = 0;i < m;i++)
	{
		long long n;
		cin>>n;
		int s = 50//50次测试
		cnt += miller_rabin(n,s);
	}
	cout<<cnt;
}
```

### 素数筛

#### 埃式筛

```c++
int prime[N+1];//储存素数
bool visit[N+1];//true表示被筛掉，不是素数
int E_sieve(int n)
{
    for(int i = 0;i <= n;i++)
    {
        visit[i] = false;
      
    }
    for(int i = 2;i * i <= n;i++)
    {
        if(!visit[i])
        {
            for(int j = i*i;j <= n;j+=i)
            {
                visit[j] = true;//标记为非素数
			}
        }
    }
    int k =  0;//记录素数个数
    for(int i = 2;i <= n;i++)
    {
        if(!visit[i])
            prime[k++] = i;
       return k;
    }
}
```

#### 欧式筛

```c++
int prime[N+1];
bool vis[N+1];
int euler_sieve(int n)
{
	int cnt = 0;
	memset(vis, 0, sizeof(vis));
	memset(prime,0,sizeof(prime));
	for(int i = 2;i <= n;i++)
	{
		if(!vis[i])
			prime[cnt++] = i;
		for(int j = 0;j < cnt;j++)
		{
			if(i * prime[i] > n)
				break;
			vis[i * prime[j]] = 1;
			if(i % prime[j] == 0)//如果i能整除它，表明i肯定不是x的最小质因数
				break;
		}
	}
}
```

### 质因数分解

#### 欧拉筛求最小共因数

求1~n 的每个数的最小质因数。

```
int prime[N+1];
bool vis[N+1];
int euler_sieve(int n)
{
	int cnt = 0;
	memset(vis, 0, sizeof(vis));
	memset(prime,0,sizeof(prime));
	for(int i = 2;i <= n;i++)
	{
		if(!vis[i])
		{
			vis[i] = i;//记录最小质因数
        	prime[cnt++] = i;
		
		}
		for(int j = 0;j < cnt;j++)
		{
			if(i * prime[i] > n)
				break;
			vis[i * prime[j]] = prime[j];//记录最小质因数
			if(i % prime[j] == 0)//如果i能整除它，表明i肯定不是x的最小质因数
				break;
		}
	}
}
```

#### 试除法

试除法求n的质因数。

（1）求最小质因数$p_1$。检测$2$~$\sqrt n$的所有素数，如果它能整除n，就是最小质因数，然后连续用$p_1$除n，去掉n中的$p_1$，得到$n_1$。

（2）再找$n_1$的最小质因数。逐个检查$p_1$~$\sqrt n$的所有素数。

（3）一直持续，直到找到所有质因数。

如果最后剩下一个大于1的数，那么它也是一个素数。

```cpp
int p[20];//记录因数，p[1]为最小因数
int c[40];//记录第i个因数的个数，
int  factor(int n)
{
	int m = 0;
	for(int i = 2;i <= sqrt(n);i++)
	{
		if(n % i == 0)
		{
			p[++m] = i;
			c[m] = 0;
			while(n % i== 0)//把n中重复的去掉
			{
				n = n / i;
				c[m]++;//去一次个数加1
			}
		}
	}
	if(n > 1)
	{
		p[++m] = n;
		c[m] = 1;
	}
	return m;
}
```

#### pollard_rho启发式分解

```c++
long long Gcd(long long a,long long b)
{
	return b ? Gcd(b,a % b):a;
}
long long mult_mod(long long a,long long b,long long n)
{
	a = a%n;
	b = b%n;
	long long ret = 0;
	while(b)
	{
		if(b&1)
		{
			ret += a;
			if(ret >= n)
				ret -= n;
		}
		a<<=1;
		if(a>=n)
			a-=n;
		b>>=1;
	}
	return ret;
}
long long pollard_rho (long long n)
{
	long long i = 1,k = 2;
	long long c = rand()%(n-1) + 1;
	long long x = rand()%n;
	long long y = x;
	while(true)
	{
		i++;
		x = (mult_mod(x,x,n) + c) % n;
		long long d = Gcd(y > x ? y - x:x - y,n);
		if(d != 1&&d!=n)
			return d;
		if(y == x)
			return n;
		if(i == k)
		{
			y = x;
			k = k<<1;
		}
	}
}
void findfac (long long n)
{
	if(miller_rabin(n))
	{
		factor[tol++] = n;
		return;
	}
	long long p = n;
	while(p >= n)
		p = pollard_rho(p);
	findfac(p);
	findfac(n / p);
}
```

## 威尔逊定理

若p为素数，则p可以整除$(p-1)! + 1$。

（1）$((p-1)!+1)\mod p=0$

（2）$(p-1)!\mod p = p -1$

（3）$(p - 1)! = pq-1$

（4）用同余表示为$(p-1)!\equiv -1(\mod p)$。

## 欧拉函数

设n是一个正整数，欧拉函数$\phi(n)$定义为不超过n且与n互素的正整数的个数。
$$
\phi(n) = \sum\limits_{i=1}^{n}[gcd(i,n) = 1]
$$
定理1 设p和q是互素的正整数，那么$\phi(pq)=\phi(p)\phi(q)$。

定理2 设n为正整数，那么
$$
n = \sum\limits_{d|n}\phi(d)
$$
其中，d|n表示d整除n，上式表示对n的正因数求和。例如n=12，那么d是1，2，3，4，6，12。

有$12=\phi(1)+\phi(2)+\phi(3)+\phi(4)+\phi(6)+\phi(12)$。

欧拉函数求解

欧拉定理 设m是一个正整数，a是一个整数且a与m互素，即$gcd(a,m) = 1$，则有$a^{\phi(m)} \equiv 1(\mod m)$。

欧拉函数通解$\phi (n) = n(1-\frac{1}{p_1})(1-\frac{1}{p_2})……(1-\frac{1}{p_k})=n\prod_\limits{i=1}^k(1-\frac{1}{p_i})$。

试除法

```c++
int euler(int n)
{
	int ans = n;
	for(int p = 2;p * p <= n;++p)
	{
		if(n % p == 0)
		{
			ans = ans / p*(p-1);
			while(n % p == 0)
				n /= p;
		}
	}
	if(n != 1)
		ans = ans / n*(n-1);
	return ans;
}
```

欧拉筛

求解1~n内的所有欧拉函数

```c++
int vis[N];//记录最小质因数
int prime[N];//记录素数
int phi[N];//记录欧拉函数
int sum[N];//欧拉函数和
void euler (int n)
{
    int cnt = 0;
	for(int i = 2;i < n;i++)
    {
        if(!vis[i])
        {
            vis[i] = i;
            prime[cnt++]=i;//记录素数
            phi[i] = i - 1;
        }
        for(int j = 0;j < cnt;j++)
        {
            if(i * prime[j] > n)
                break;
            vis[i * prime[j]] = prime[j];//记录最小质因数
            if(i % prime[j] == 0)
            {
                phi[i * prime[j]] = phi[i] * prime[j];
                break;
			}
            phi[i * prime[j]] = phi[i] * phi[prime[j]];
		}
	}
}
```

## 狄利克雷卷积

设f和g算术函数，记f和g的狄利克雷卷积为f、$f *g$，定义为
$$
(f*g)(n) = \sum\limits_{d|n}f(d)g(\frac{n}{d})
$$
定义恒等函数$I(n) = n$、常数函数$1(n) = 1$，他们卷积是
$$
(I*1)(N) = \sum\limits_{d|n}I(d)1(\frac{n}{d})=\sum\limits_{d|n}d*1=\sum\limits_{d|n}d=\sigma(n)
$$
把它记为$I*1=\sigma$。$\sigma(n)$是“因数和函数”的符号。

## 莫比乌斯

莫比乌斯函数$\mu(n)$定义为
$$
\mu(n)=\begin{cases}
1,&n=1\\(-1)^r,&n=p_1p_2……p_r，其中p_i为不同发的素数\\0，&其他
\end{cases}
$$
莫比乌斯函数的和函数在整数n处的值$F(n) = \sum\limits_{d|n}\mu(d)$，满足
$$
\sum\limits_{d|n}\mu(d)=\mu(n)=\begin{cases}
1,&n=1\\0，&n > 1
\end{cases}
$$
线性筛求1~n的莫比乌斯函数

```c++
bool  vis[N];
int prime[N];
int Mob[N];
void Mobius_sieve()
{
	int cnt = 0;
	vis[1] = 1;
	Mob[1] = 1;
	for(int i = 2;i <= n;i++)
	{
		if(!vis[i])
		{
			prime[cnt++] = i;
			Mob[i] = -1;
		}
		for(int j = 0;i < cnt&&1LL * prime[j] * i <= n;j++)
		{
			vis[prime[j] * i] = 1;
			Mob[i*prime[j]] = (i % prime[j]) ? -Mob[i] :0);
			if(i % prime[j] == 0)
				break;
		}
	}
}
```

### 莫比乌斯反演

若f是算术函数，F为f的和函数，对任意正整数n，满足$F(n) = \sum\limits_{d|n}f(d)$，则有$f(n)=\sum\limits_{d|n}\mu(d)F(\frac{n}{d})$。

使用莫比乌斯反演求欧拉函数

```c++
int phi[N];
vector<int> fac[N];
void get_eulers()
{
	for(int i = 1;i <= n - 10;i++)
	{
		for(int j = i;j <= n - 10;j+=i)
		{
			fac[j].push_back(i);
		}
	}
	phi[1] = 1;
	for(int i = 2;i <= n - 10;i++)
	{
		phi[i] = i;
		for(auto j : fac[i])
		{
			if(j == i)
			{
				continue;
			}
			phi[i] -= phi[j];
		}
	}
}
```

## 杜教筛

```c++
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
const int N = 5e6+7;
int prime[N];
bool vis[N];
int mu[N];
ll phi[N];
unordered_map<int,int>summu;
unordered_map<int,ll>sumphi;
void init()
{
    int cnt = 0;
    vis[0] = vis[1] = 1;
    mu[1] = phi[1] = 1;
    for(int i = 2;i < N;i++)
    {
        if(!vis[i])
        {
            prime[cnt++] = i;
            mu[i] = -1;
            phi[i] = i - 1;
        }
        for(int j = 0;j < cnt&&i * prime[j] < N;j++)
        {
            vis[i * prime[j]] = 1;
            if(i % prime[j])
            {
                mu[i * prime[j]] = -mu[i];
                phi[i * prime[j]] = phi[i] * phi[prime[j]];
            }
            else
            {
                mu[i * prime[j]] = 0;
                phi[i * prime[j]] = phi[i] * prime[j];
                break;
            }
        }
    }
    for(int i = 1;i < N;i++)
    {
        mu[i] += mu[i - 1];
        phi[i] += phi[i - 1];
    }
}
int gsum(int x)
{
    return x;
}
ll getsmu(int x)
{
    if(x < N)
        return mu[x];
    if(summu[x])
        return summu[x];
    ll ans = 1;
    for(ll l = 2,r;l <= x;l = r + 1)
    {
        r = x /(x/ l);
        ans -= (gsum(r) - gsum(l - 1)) * getsmu(x/l);
    }
    return summu[x] = ans / gsum(1);
}
ll getsphi(int x)
{
    if(x < N)
        return phi[x];
    if(sumphi[x])
        return sumphi[x];
    ll ans = x*((ll)x+ 1 ) / 2;
    for(ll l = 2,r;l <= x;l = r + 1)
    {
        r = x/(x/l);
    	ans -= (gsum(r)-gsum(l - 1))*getsphi(x/l);
    }
    return sumphi[x] = ans/gsum(1);
}
int main ()
{
    init();
    int t;
    cin>>t;
    while(t--)
    {
        int n;
        cin>>n;
        cout<<getsphi(n)<<" "<<getsmu(n)<<endl;
    }
}
```

# 组合数学

### 卡特兰数



C0 = 1,         
C1 = 1,         C2 = 2,          C3 = 5,          C4 = 14,          C5 = 42,
C6 = 132,       C7 = 429,        C8 = 1430,       C9 = 4862,        C10 = 16796,
C11 = 58786,    C12 = 208012,    C13 = 742900,    C14 = 2674440,    C15 = 9694845,
C16 = 35357670, C17 = 129644790, C18 = 477638700, C19 = 1767263190, C20 = 6564120420, ...

二项式定理

求二项式系数方法

1.递推公式$C^r_n = C^r_{n-1} + C^{r-1}_{n-1}$时间复杂度$O(n^2)$;

2.使用逆计算，$C^r_n =\begin{pmatrix}n\\r\end{pmatrix} = \frac{n!}{r!(n-r)!}$。$C^r_n\mod m =\frac{n!}{r!(n-r)!} \mod m=(n!\mod m)((r!)^{-1}\mod m)((n-r)!)^{-1}\mod m)\mod m$。

输出杨辉三角前n行

```c++
#include <bits/stdc++.h>
using namespace std;

int a[21][21];
int main ()
{
	int n;
	cin>>n;
	for(int i = 1;i <= n;i++)
		a[i][1] = a[i][i] = 1;
	for(int i = 1;i <= n;i++)
		for(int j = 2;j < i;j++)
			a[i][j] = a[i-1][j] + a[i-1][j-1];
	for(int i = 1;i <= n;i++)
	{
		for(int j = 1;j <= i;j++)
			cout<<a[i][j]<<"  ";
		cout<<"\n";
	}
	return 0;
}
```

P1313

给定多项式$(ax+by)^k$，求多项式展开后第$x^n*y^m$项的系数。

$(ax+by)^k=\sum\limits_{r=1}^kC_k^r(ax)^r(by)^{k-r}=\sum\limits_{r=1}^kC_k^ra^rx^rb^{k-r}y^{k-r}=\sum\limits_{r=1}^k(C_k^ra^rb^{k-r})x^ry^{k-r}$。

```c++
#include <bits/stdc++.h>
using namespace std;
#define mod 10007
int fac[10001];//阶乘
int inv[10001];//逆元
int fastPow(int a,int b)
{
	int ans = 1;
	a = a % mod;
	while(b)
	{
		if(b & 1)
		{
			ans = ans * a %mod;
		}
		a = a *a %mod;
		b = b>>1;
	}
	return ans;

}
int C(int n,int m)\\计算组合数
{
	return (fac[n] * inv[m] % mod *inv[n - m] % mod) % mod;
} 
int main ()
{
	int a,b,n,m,k,ans;
	cin>>a>>b>>k>>n>>m;
	fac[0] = 1;
	for(int i = 1;i <= n + m;i++)
	{
		fac[i] = (fac[i - 1] * i)%mod;
		inv[i] = fastPow(fac[i],mod - 2);
	}	
	ans = (fastPow(a,n) % mod * fastPow(b,m) % mod *C(k,n) % mod) %mod;
	cout<<ans;
	return 0;
}
```



# 位运算

位运算中的思路。考虑运算过程之间的位是否有影响，即是否进位，减法肯定不会进位，需要考虑是否结果为-1，即使借位，而加法需要考虑进位，即结果为2。如果没有影响，那么可以列出真值表构造结果。

位运算中的2进制应该是左移或者右移来模拟。

## 与

通过与1、10、100、运算，可以知道当前位数的对应的值。

判断n个数字的位值是否等于特定的值

比如需要判断a、b、c的位数等于1、0、0。通过与运算构造与的结果为1即可。

```c++
if(a&!b&!c)
```



## 异或

Y=A’⋅B+A⋅B’

恒等律：X ⊕ 0 = X

归 零 律 ： X ⊕ X = 0 

性质

① 自反性：$a ⊕ b ⊕ b = a$

② 无序性：$a ⊕ b ⊕ c ⊕ d = b⊕ d ⊕ a ⊕ c$

③ 可移项性：$a ⊕ b = c$ 可移项为 $a = b ⊕ c$，移项时无需改变符号

④ 位独立性：每一位的异或互相独立，比如 $1010 ⊕ 1110 = 0100$

**例1**：给定一个数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出只出一次的元素

解：异或两次不变找出最后的结果，自反性+无序性。

**例2**：异或前缀和。给定一个非空整数数组，请你求出指定子数组的所有元素异或之和。

```c++
int a
//构造异或前缀和数组
for(int i = 0;i < arr.length;i++)
{
	prexorsum[i + 1] = prexorsum[i] ^ arr[i];
}
//使用异或前缀和数组
for(int i = 0;i , )
```

# 博弈论

## 取子游戏

步骤1:将所有终结位置标记为必败点（P点）。

步骤2:将所有一步操作能进入必败点(P点）的位置标记为必胜点(N点)

步骤3:如果从某个点开始的所有一步操作都只能进入必胜点(N点），则将该点标记为必败点(P点)。

步骤4:如果在步骤3未能找到新的必败(P点），则算法终止;否则，返回到步骤2。

例如$S=\{1,3,4\}$,先拿完的胜利

可以看出1到10之间的P和N点

$0\ 1\  2\ 3\ 4\ 5\ 6\ 7\ 8\ 9\ 10$

$PNPNNNNPNPN $

## Nim游戏

三堆石头，轮流从某堆取，可取任意数量，最后取完的胜利。

对于Nim游戏的某个位置当且仅当各部分的nim-sum等于0的时候，$a⊕b⊕c=0$，则当前位于必败点。

对于必胜点，判断可行的方案。

例如$a⊕b⊕c=S$,此时S不等于0，那么先手必须将他变成0。此时需要S分别于上面的abc异或， 如果结果变小了，那么就是要找的目标。

## SG函数

X节点的SG值是去除X的后继节点的SG值后的最小的非负整数。

必败点：当节点x的sg(x) = 0，必胜点：当节点x的sg(x) > 0

例如$S=\{1,2,3\}$。$sg(0) = 0$,1的后继只有0那么$sg(1) = 1$，$sg(2) = 2,sg(3) = 3,sg(4)=0,sg(5)=1$。

如果图游戏G由若干子图游戏Gi组成，即：$G=G_1+……+G_n$,设$g_i$是$G_i(i=1,……,n)$的SG函数值，那么大游戏的总sg值等于每个子游戏的sg值的异或和，$g(x_1,……,x_n)=g_1(x_1)⊕……⊕g_n(x_n)$ 



# STL

## STL算法

### sort函数

### accumulate函数

累加函数，给定三个参数，前两个为元素范围，最后一个为累加初值。最后结果为累加初始值+元素范围内所有元素和

```c++
vector<int> a = {3,2,1};
cout<<accumulate(a.begin(),a.end(),1);
//7
```

累乘

```c++
int main() {
    vector<int> a{1, 2, 3, 4};
    int sum = accumulate(a.begin(),a.end(),1,multiplies<int>()); 
    cout << sum << endl;	// 输出24
}

```

拼接字符串

```c++
vector<string> words{"this ","is ","a ","sentence!"};
string init = "hello, ",res;
res = accumulate(words.begin(),words.end(),init);  // 连接字符串
cout << res << endl;//hello, this is a sentence!
```



### rotate函数

rotate(first,n_first,last);

对一系列元素执行左旋转，交换[first,last)范围内元素，n_first成为新的第一个元素，n_first-1成为最后一个元素。

```c++
vector<int> a = {3,2,1};
for(auto &i:a)
{
	cout<<i<<" ";
}
cout<<"\n";
rotate(a.begin(),a.begin()+1,a.end());
for(auto &i:a)
{
	cout<<i<<" ";
}
3 2 1
2 1 3
```

##### rotate函数实现

将x分为ab两段，选择x其实就是交换ab使之变为ba。考虑两种情况：
a比b短，将ab表示为ab1b2，其中a与b2长度相同，最终我们需要的是b1b2a。先交换a与b2，向量变为b2b1a，接下来只要交换b2b1即可。
a比b长，将ab表示为a1a2b，其中a1与b长度相同，最终我们需要的是ba1a2。先交换a1与b，向量变为ba2a1，接下来只要交换a2a1即可。

比如123456，此时交换变成345612，可以先变成12|3456，然后变成12|34|56,然后交换一次，变成56|34|12，最后变成34|56|12。

```c++
template <class ForwardIt>
void rotate4(ForwardIt first, ForwardIt middle, ForwardIt last)
{
    ForwardIt next = middle;
    while (first != next)
    {
        std::iter_swap (first++, next++);
        if (next==last) next = middle;
        else if (first==middle) middle = next;
    }
}
递归
template <class ForwardIt>
void rotate3(ForwardIt first, ForwardIt middle, ForwardIt last)
{
    if(first == middle) return;
    if(middle == last) return;
    ForwardIt oldmid = middle;
    while(first != oldmid && middle != last)
    {
        std::iter_swap(first++, middle++);
    }
    rotate3(first, first == oldmid ? middle : oldmid, last);
}
```

更简单的方法

ab,先对a求逆，然后对b，最后对整体。

比如1234567，先对a为2134567，然后b为2176543，最后为3456712。

$ab->a^rb->a^rb^r->(a^rb^r)^r=ba$。

```c++
reverse(first,middle);
reverse(middle,last);
reverse(first,last);
```



### next_permutation函数

用于生成序列的全排列，

```c++
int a[]={1,2,3};
do{
	cout<<a[0]<<" "<<a[1]<<" "<<a[2]<<"\n";
}while(next_permutation(a,a+3));
1 2 3
1 3 2
2 1 3
2 3 1
3 1 2
3 2 1
```

若当前调用排列已经达到最大字典序，比如321，函数返回false。

修改函数参数，(a,a+2)，可以只对部分长度全排列。

### prev_permutation函数

与next_permutation相反，由原排列得到字典序中上一个最近排列，前一个全排列

```c++
int a[]={3,2,1};
do{
	cout<<a[0]<<" "<<a[1]<<" "<<a[2]<<"\n";
}while(prev_permutation(a,a+3));
3 2 1
3 1 2
2 3 1
2 1 3
1 3 2
1 2 3
```

## Queue

```c++
queue<int> a;
a.push(3);//队列添加元素：
a.pop();//去掉队首元素：
a.front();//访问队首元素：
a.back();//访问队尾元素：
a.empty();//判断是否为空：
a.size();//返回队列大小：
```

## Stack

```c++
stack<int> a;
a.push(3);//栈顶添加元素：
a.pop();//删除元素：
a.top();//访问栈顶元素，要先确保栈非空：
a.empty();//判断是否为空：
a.size();//返回栈大小：
```

栈和队列一样没有clear函数，需要循环调用出栈函数

```c++
while(!s.empty())
{
	s.pop();
}
```

栈的问题中可以先入一个特殊字符防止RE，防止栈空的时候访问栈顶



## String

### 插入字符串

```c++
string s1("abcd");
string s2("12");
s1.insert(2,"123"); //s1 = "ab123cd" index之前插入
s1.insert(3,s2);//s1 = "abc12123cd"
s1.insert(3,5,'X');//s1="abcXXXXX12123cd" index之前插入5个X
```

### 删除字符串

```c++
string s1("abcdlds");
s1.erase(1,3);//s1 = "alds";删除l-r区间所有字符
s1.erase(1);//s1 = "a";从index开始删除
```

交换两个String对象的内容

swap成员函数交换两个Stirng对象的内容

```c++
string s1("We");
string s2("Ce");
s1.swap(s2);//s1 = "Ce" s2 = "We"
```

### 查找字符串

```c++
std::string str = "yourlmelckme";
std::string key = "me";
int pos1 = str.find(key);     // 4 返回第一个查找到的首字母下标,查找第一次出现的位置
int pos2 = str.find(key, 7);  // 17 查找[index,end]第一次出现的位置

std::string key2 = "aa";
auto it1 = str.find(key);
auto it2 = str.find(key2);

if(it1 != std::string::npos) {
    std::cout << it1 << std::endl;
} else {
    std::cout << "Not found!" << std::endl;
}

if(it2 != std::string::npos) {
    std::cout << it2 << std::endl;
} else {
    std::cout << "Not found!" << std::endl;
}
```

### String对象比较

可以使用<、<=、==、!=、>=、>比较，也可以使用compare函数

### String对象连接

string连接可以使用+和+=运算符进行，也可以使用append函数

```
str.append(3, 's');
//str="abc"
//str="abcsss"

str.append(str1);
//str="abc", str1="123"
//str="abc123"

str.append(str1, 2);
//在 str 末尾添加 str1[2]~str1[n-1]
//例:str="abc", str1="123456"
//运行之后 str="abc3456"

str.append(str1, 2, 3);
//在 str 末尾添加 str1[2]~str1[2+3-1]
//例:str="abc", str1="123456"
//运行之后 str="abc345"

str.append(str1.begin()+1,str1.end()-1);
//将 str1 区间内的元素添加到 str 末尾
//例:str="abc", str1="123456"
//运行之后 str="abc2345"
```

### 求String对象的子串

substr (size_t pos  = 0, size_t len = pos)

substr函数用于从字符串中提取字符串。pos是字符串开始的位置，默认为0，len是提取字符串的长度，如果不提供len，npos将被认证默认值，意味着字符串将从pos开始一直延伸至末尾。

```c++
std::string s = "Hello,World!";//索引从0开始
//提取整个字符串
std::string sub = s.substr();
//sub = "Hello,World!"
//从字符串中间截取
std::string sub = s.substr(6);//从索引6开始
//sub = "world!"
//提取特定长度的子字符串
std::string sub = s.substr(6,2);//从索引6开始提取2个字符
//sub = "wo";
```

## Vector

vector向量，动态数组

```c++
vector<int> a;
a.begin();//取首元素的迭代器
a.end();//取尾元素的下一地址
a.front();//取首元素的值
a.back();//取尾部的值
int value0 = a[0];//下标访问
a.push_back(value);//尾部添加一个元素
a.pop_back();//删除尾部第一个元素
a.empty();//判空
a.size();//求向量元素个数
```

vector的定义

```c++
vector<int> a;//初始化一个size为0的vector
vector<int> a(10);//初始化10个默认值为0的元素
vector<int> a(10,1);//初始化了10个值为1的元素
```

## Set

有序性，所有操作是$log^n$，红黑树实现。只能使用迭代器访问

作用：去重，升序排序。

```c++
set<int> s;//声明
s.clear();//清空
s.insert(x);//插入元素，如果之前没有，则插入后排序，否则不插入。
int hav = s.count(x);//查找是否有x，返回0或1
set<int>::iterator it = s.find(x);//查找x并返回迭代器
bool isempty = s.empty();//判断空集
int n = s.size();//元素个数
s.erase(x);//删除
```

### 访问

使用迭代器访问，注意set不支持`it < st.end()`的写法

```c++
set<int> st;
for(set<int>::iterator it = st.begin();it != st.end();it++)
{
	cout<<*it;
}

// since c++ 11
std::set<int> st = {1, 2, 3, 4, 5};
for(const auto& s : st) {
    std::cout << s << ' ';
}
```

### 降序排列

```c++
set<int,greater<int> > st;
set<int,greater<int> >::iterator it;
st.insert(1);
for(it = st.begin();it != st.end();it++)
{
	cout<<*it;
}
```

如果是结构体类型，需要在结构体中重载小于运算符。

* 仿函数定义

  ```cpp
  template<class T>
  struct Less {
      bool operator()(const T& x, const T& y) const {
          return x < y;
      }
  };
  
  template<class T>
  struct Greater {
      bool operator()(const T& x, const T& y) const {
          return x > y;
      }
  };
  
  int main() {
      std::set<int, Greater<int>> st = {1, 2, 3, 4, 5};
  
      for (const auto& s : st) {
          std::cout << s << ' ';
      }
      std::cout << std::endl;
  
      return 0;
  }
  ```

### unordered_set

底层实现 hash table，存储唯一对象集合

#### 遍历

```cpp
/**
 * 遍历 since c++ 11
 * 可以看出 unordered_set 是无序，不重复的
 */
template <class Os, class K>
Os& operator<<(Os& os, const std::unordered_set<K>& v) {
    os << '[' << v.size() << "] {";
    bool o{};
    for (const auto& e : v) {
        os << (o ? ", " : (o = 1, " ")) << e;
    }
    return os << " }";
}

std::unordered_set<int> us = {2, 7, 1, 8, 2, 8};
std::cout << us << std::endl;  // [4] { 8, 1, 7, 2 }
```

#### 插入元素

O(1)

若重复则不做任何事 

如果操作后新的元素数量大于原 max_load_factor() \* bucket_count() 则会发生重散列。如果（因插入而）发生了重散列，索引迭代器均会失效。否则（未发生重散列），则迭代器不会失效。

```cpp
us.insert(9);
std::cout << us << std::endl;  // [5] { 9, 8, 1, 7, 2 }
```

#### 移除元素

O(1)

```cpp
us.erase(us.begin());             // 移除开头
us.erase(std::next(us.begin()));  // 移除第二个元素
std::cout << us << std::endl;     // [3] { 8, 7, 2 }

us.erase(7);                   // 移除具体值
std::cout << us << std::endl;  // [2] { 8, 2 }

// iterator erase( const_iterator first, const_iterator last );
```

#### 合并两个集合

 O(N)

```cpp
std::unordered_set<char>
    p{'C', 'B', 'B', 'A'},
    q{'E', 'D', 'E', 'C'};

p.merge(q);
std::cout << "p: " << p << std::endl;  // p: [5] { E, D, A, B, C }
std::cout << "q: " << q << std::endl;  // q: [1] { C }
```

#### 返回匹配特定键的元素数量

只要set中存在这个元素，count就返回1，否则返回0

```cpp
std::unordered_set set{2, 7, 1, 8, 2, 8, 1, 8, 2, 8};
std::cout << set << std::endl;  // [4] { 8, 1, 7, 2 }

const auto [min, max] = std::ranges::minmax(set);  // since c++ 20
for (int i = min; i <= max; ++i) {
    if (set.count(i) == 1) {
        std::cout << i << ' ';
    }
}
std::cout << std::endl;
```

#### 查找指定元素

找得到返回迭代器，找不到返回 end()

```cpp
if (auto res = set.find(2); res != set.end()) {
    std::cout << "Find: " << *res << std::endl;
} else {
    std::cout << "Not found!" << std::endl;
}
```

#### 判断集合中是否存在该元素 *since c++ 20*

```cpp
for (int x : {2, 5}) {
    if (set.contains(x)) {
        std::cout << "Find: " << x << std::endl;  // Find: 2
    } else {
        std::cout << "Not found: " << x << std::endl;  // Not found: 5
    }
}
```

#### 清空集合

```cpp
set.clear();
std::cout << set << std::endl;  // [0] { }
```

### multiset

底层实现：红黑树

允许元素重复

基本操作O(log n)

// TODO

## Map

键值对(key/value)容器，迭代器可以修改value，不能修改key。Map会根据key自动排序。key不一定是int类型，只要是重载的<操作符的类型均可

```c++
map<int,string>m;
m.count(k);//返回m中键值等于k的元素个数
m.find(k);//存在返回指向元素的迭代器，否则返回end()
m.erase(k);//删除m中键为k的元素，返回删除元素的个数。
m.erase(p);//删除迭代器p所指向的元素
m.insert(e);//e是一个用在m上的一个pair，如果e.first不在m中，则插入一个值为e.second的新元素；如果该键在m中存在，不做任何操作。
m.clear();//清空
m,empty();//判空
```

访问

```c++
map<int,string>::iterator iter;
for(iter = mp.begin();iter != mp.end();iter++)
{
	cout<<iter->first<<" "<<iter->second<<endl;
}
```

```
auto it = mp.begin();
for(auto &[k,v]:mp)
{

}
```

#### unordered_map

// TODO

#### multimap

// TODO

## Pair

定义

```c++
pair<T1, T2> p1;            //创建一个空的pair对象（使用默认构造），它的两个元素分别是T1和T2类型，采用值初始化。
pair<T1, T2> p1(v1, v2);    //创建一个pair对象，它的两个元素分别是T1和T2类型，其中first成员初始化为v1，second成员初始化为v2。
make_pair(v1, v2);          // 以v1和v2的值创建一个新的pair对象，其元素类型分别是v1和v2的类型。
p1 < p2;                    // 两个pair对象间的小于运算，其定义遵循字典次序：如 p1.first < p2.first 或者 !(p2.first < p1.first) && (p1.second < p2.second) 则返回true。
p1 == p2；                  // 如果两个对象的first和second依次相等，则这两个对象相等；该运算使用元素的==操作符。
p1.first;                   // 返回对象p1中名为first的公有数据成员
p1.second;                 // 返回对象p1中名为second的公有数据成员
```

创建和初始化

```c++
pair<string, string> anon;        // 创建一个空对象anon，两个元素类型都是string
pair<string, int> word_count;     // 创建一个空对象 word_count, 两个元素类型分别是string和int类型
pair<string, vector<int> > line;  // 创建一个空对象line，两个元素类型分别是string和vector类型
```

```c++
pair<string, string> author("James","Joy");    // 创建一个author对象，两个元素类型分别为string类型，并默认初始值为James和Joy。
pair<string, int> name_age("Tom", 18);
pair<string, int> name_age2(name_age);    // 拷贝构造初始化
```

赋值

```c++
pair<int, double> p1(1, 1.2);
pair<int, double> p2 = p1;     // copy construction to initialize object
pair<int, double> p3；
p3 = p1;    // operator =
```

操作

```c++
pair<int ,double> p1;
p1.first = 1;
p1.second = 2.5;
cout<<p1.first<<' '<<p1.second<<endl;
//输出结果：1 2.5
```

遍历

```

```

迭代器

```c++
vector<int> a;
vector<int>::iterator iter;
for(iter = a.begin();iter != a.end();iter++)
{
	cout<<*iter<<endl;
}
```

## tuple

// TODO

# 其他

## int128

```c++
__int128 read() {
	char arr[30];
	__int128 res = 0;
	scanf("%s", arr);
	for (int i = 1; i <= strlen(arr); i++) {
		res *= 10;
		res += arr[i]-'0';
	}
	return res;
}
void print (__int128 num) {
	if (num > 9) { print(num / 10); }
	putchar(num % 10 + '0');
}

```



### 取一行字符串

cin.getline(a,101);

使用扫描一行，扫描一行之前光标应在当前行首，如果没有及时换行，那么第一次读取的可能为空，所以有时候应当加入getchar（)使得光标换行。

### 关闭输入输出流同步，解绑输入输出流

```c++
ios::sync_with_stdio(0);
cin.tie(0);
cout.tie(0);
```

注意事项：

1.不适用于混合输入输出：如果你的程序在输入输出中同时使用了C++的输入输出流和C标准库的输入输出函数（如scanf和printf），则不应该使用这段代码。因为这会导致输入输出之间的不同步。

2.不能混用输入输出函数：在使用了这段代码后，应避免使用C标准库的输入输出函数（如printf和scanf），因为这些函数与输入输出流的同步已被关闭。简单来说，关闭了同步流，就不能用scanf和printf。

3.关闭了同步流，不能用getchar()函数。

4.不影响程序正确性：关闭输入输出流的同步不会影响程序的正确性，它只是为了提高程序的执行效率。因此，在一些对输入输出性能要求较高的场景下，可以考虑使用这段代码。

5.关闭了同步流（也就是使用这段代码），不能再用cout<<endl。而应该改用cout<<'\n'。

因为通常情况下，cout<<endl会输出一个换行符并刷新输出缓冲区，确保内容立即显示。但是，当使用了上述代码时，cout<<endl不再具有自动刷新缓冲区的功能。
6.这三行代码必须一起用，不能只用第一行代码，使用这三行代码时，得用C++的头文件。算法竞赛为了方便，一般使用万能头文件bits/stdc++.h。

## 注

如果要删除第一个和第二个元素，

不是erase(a.begin());和erase(a.begin()+1)，而是两次erase(a.begin())。即第一次删除会改变所有元素的位置。

注意$i*i$或者$n*n$会爆LL，多乘以一个1LL。

使用stl一定要在每次测试样例结束后初始化

