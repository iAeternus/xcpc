# äºŒåˆ†

```c++
int bisearch(int a[],int n,int x)
{
    int left = 0,right = n-1;
    while(left<=right)
    {
        int mid = (left+right)>>1;
        if(a[mid] == x)
            return mid;
        if(x > a[mid])
            left = mid+1;
        else
            right = mid- 1;
	}
    return -1;
}

```

äºŒåˆ†ç­”æ¡ˆå¸¸è§æ­¥éª¤

1ã€è¯æ˜é—®é¢˜å•è°ƒæ€§ã€‚

2ã€ç¡®å®šä¸Šä¸‹ç•Œ

3ã€è®¾è®¡check()å‡½æ•°ã€‚

4ã€ä¸Šä¸‹ç•Œä¹‹å†…äºŒåˆ†ç­”æ¡ˆã€‚

# ä¸‰åˆ†

 	 	

# åŒºé—´æœ€å€¼

å¯ä»¥ä½¿ç”¨æ ‘çŠ¶æ•°ç»„è§£ç­”ï¼Œä½†ä¸€èˆ¬ç”¨stã€çº¿æ®µæ ‘å’Œç¬›å¡å°”æ ‘æ›´æ–¹ä¾¿
ä¸‹é¢ç”¨stç®—æ³•
è§£ç­”é™æ€åŒºé—´æœ€å€¼ï¼Œè¾“å‡ºç»™å®šl,ræœ€å¤§å€¼å’Œæœ€å°å€¼ä¹‹å·®

```c++
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
const int N=5e4+1;
int Log2[N];
int n,q;
int arr[N];
int dp_min[N][17],dp_max[N][17];
void init()
{
    Log2[0]=-1;
    for(int i=1;i<=n;i++)
        Log2[i]=Log2[i>>1]+1;;
    for(int i=1;i<=n;i++)
    {
        dp_max[i][0]=arr[i];
        dp_min[i][0]=arr[i];
    }
    int p=Log2[n];
    for(int k=1;k<=p;k++)
        for(int s=1;s+(1<<k)<=n+1;s++)
        {
            dp_min[s][k]=min(dp_min[s][k-1],dp_min[s+(1<<(k-1))][k-1]);
            dp_max[s][k]=max(dp_max[s][k-1],dp_max[s+(1<<(k-1))][k-1]);
        }
}
int solve(int l,int r)
{
    int x,y;
    int k=Log2[r-l+1];
    x=max(dp_max[l][k],dp_max[r-(1<<k)+1][k]);
    y=min(dp_min[l][k],dp_min[r-(1<<k)+1][k]);
    return x-y;
}
int main()
{
    int l, r,ans;
    cin>>n>>q;
    for(int i=1;i<=n;i++)
        cin>>arr[i];
    init();
    while(q--)
    {
        cin>>l>>r;
        ans=solve(l,r);
        cout<<ans<<endl;
    }
    return 0;
}
```

stç®—æ³•æ€æƒ³ä¸ºä¸€ä¸ªåŒºé—´å˜æˆä¸¤ä¸ªæœ‰é‡å åŒºé—´çš„ç­”æ¡ˆï¼Œæ•…é€‚ç”¨äºé‡å¤è´¡çŒ®çš„é¢˜ç›®å¦‚æœ€å¤§å€¼æœ€å°å€¼ï¼ŒåŒºé—´æœ€å¤§å…¬çº¦æ•°ç­‰

# æ ‘çŠ¶æ•°ç»„

## å•ç‚¹ä¿®æ”¹+åŒºé—´æŸ¥è¯¢

```c++
#include <iostream>
using namespace std;
const int N = 1e5 + 10;
int a[N],c[N];
int n,m;
int lowbit(int x)
{
	return x & -x;
}
void add(int x,int k)
{
	for(int i = x;i <= n;i += lowbit(i))
	{
		c[i] += k;
	}
}
int sum(int x)
{
	int res = 0;
	for(int i = x;i;i -= lowbit(i))
	{
		res += c[i];
	}
	return res;
}
int main()
{
    cin >> n >> m;
	for(int i = 1;i <= n;i++)
	{
		cin >> a[i];
		add(i,a[i]);
	}
	while(m--)
	{
		int l,r;
		cin >> l >> r;
		cout << sum(r) - sum(l - 1) << endl;
	}
	return 0;
}
```

## åŒºé—´ä¿®æ”¹+åŒºé—´æŸ¥è¯¢

å®šä¹‰å·®åˆ†æ•°ç»„ä¸ºd,åŸæ•°ç»„ä¸ºaåˆ™æœ‰ï¼š
$
d_i=a_i-a_{i-1}(1\leq i\leq n)
$
$
a_i=\sum_{j=1}^{i}d_j(1\leq i\leq n)
$
$
\sum_{i=1}^{k}a_i=\sum_{i=1}^{k}\sum_{j=1}^{i}d_j=
\sum_{j=1}^{k}\sum_{i=j}^{k}d_j=k\sum_{i=1}^{k}d_i-\sum_{i=1}^{k}(i-1)d_i
$
æ•…ç”¨ä¸¤ä¸ªæ ‘çŠ¶æ•°ç»„ç»´æŠ¤$d_i$å’Œ$(i-1)\cdot d_i$å³å¯

```c++
//åŒºé—´ä¿®æ”¹ï¼ŒåŒºé—´æŸ¥è¯¢æ ‘çŠ¶æ•°ç»„åšæ³•
#include<iostream>
#include<cstring>
using namespace std;
typedef long long ll;
const int N=1e5+10;
ll tr1[N],tr2[N];
int n,m;
int lowbit(int x)
{
    return x&(-x);
}
void update1(int x,ll d)
{
    while(x<=n)
    {
        tr1[x]+=d;
        x+=lowbit(x);
    }
}
ll sum1(int x)
{
    ll ans=0;
    while(x)
    {
        ans+=tr1[x];
        x-=lowbit(x);
    }
    return ans;
}
void update2(int x,ll d)
{
    while(x<=n)
    {
        tr2[x]+=d;
        x+=lowbit(x);
    }
}
ll sum2(int x)
{
    ll ans=0;
    while(x)
    {
        ans+=tr2[x];
        x-=lowbit(x);
    }
    return ans;
}
int main()
{
    cin>>n>>m;
    int pre=0,a;
    for(int i=1;i<=n;i++)
    {
        scanf("%lld",&a);
        update1(i,a-pre);
        update2(i,(i-1)*(a-pre));
        pre=a;
    }
    while(m--)
    {
        int p,l,r;
        ll d;
        scanf("%d",&p);
        if(p == 1)
        {
            scanf("%d%d%lld",&l,&r,&d);
            update1(l,d);
            update1(r+1,-d);
            update2(l,d*(l-1));
            update2(r+1,-d*r);
        }
        else if(p == 2)
        {
            scanf("%d%d",&l,&r);
            printf("%lld\n",r*sum1(r)-sum2(r)-(l-1)*sum1(l-1)+sum2(l-1));
        }
    }
    return 0;
}
```

## åŒºé—´æœ€å€¼

hdu1754

Q a b æŸ¥è¯¢åŒºé—´[a,b]çš„æœ€å¤§å€¼
U a b ä¿®æ”¹ç¬¬aä¸ªæ•°ä¸ºb

```c++
#include<iostream>
#include<cstring>
#include<algorithm>

using namespace std;
const int N=2e5+10;
int a[N],tr[N];
int n,m;
int lowbit(int x)
{
    return x&(-x);
}
void update(int x,int val)
{
    while(x<=n)
    {
        tr[x]=val;
        for(int i=1;i<lowbit(x);i<<=1)
        {
            tr[x]=max(tr[x],tr[x-i]);
        }
        x+=lowbit(x);
    }
}
int query(int l,int r)
{
    int res=0;
    while(l<=r)
    {
        res=max(res,a[r]);
        r--;
        while(r-l>=lowbit(r))
        {
            res=max(res,tr[r]);
            r-=lowbit(r);
        }
    }
    return res;
}
int main()
{
    while( ~scanf("%d%d",&n,&m))
    {
        memset(tr,0,sizeof tr);
        for(int i=1;i<=n;i++)
        {
            scanf("%d",&a[i]);
            update(i,a[i]);
        }
        while(m--)
        {
            char op[2];
            int x,y;
            scanf("%s%d%d",op,&x,&y);
            if(*op=='Q')printf("%d\n",query(x,y));
            else
            {
                a[x]=y;
                update(x,y);
            }
        }
    }
    return 0;
}
```

## äºŒç»´åŒºé—´ä¿®æ”¹+åŒºé—´æŸ¥è¯¢

ç±»ä¼¼äºä¸Šè¿°æ–¹æ³•æ¨å¯¼å¯çŸ¥ç»´æŠ¤å››ä¸ªæ•°ç»„å³å¯
ç¼ºç‚¹æ˜¯ç©ºé—´è€—è´¹è¾ƒå¤§

```c++
#include<iostream>
#include<cstring>
#include<algorithm>

using namespace std;
const int N=2055;
int t1[N][N],t2[N][N],t3[N][N],t4[N][N];
int n,m;
int lowbit(int x)
{
    return x&(-x);
}
void update(int x,int y,int d)
{
    for(int i=x;i<=n;i+=lowbit(i))
        for(int j=y;j<=m;j+=lowbit(j))
        {
            t1[i][j]+=d,t2[i][j]+=x*d;
            t3[i][j]+=y*d,t4[i][j]+=x*y*d;
        }
}
int sum(int x,int y)
{
    int res=0;
    for(int i=x;i>0;i-=lowbit(i))
        for(int j=y;j>0;j-=lowbit(j))
        {
            res+=(x+1)*(y+1)*t1[i][j]-(y+1)*t2[i][j]-(x+1)*t3[i][j]+t4[i][j];
        }
        return res;
}
int main()
{
    char ch[2];
    scanf("%s",ch);
    cin>>n>>m;
    while(~scanf("%s",ch))
    {
        int a,b,c,d,delta;
        scanf("%d%d%d%d",&a,&b,&c,&d);
        if(ch[0]=='L')
        {
            scanf("%d",&delta);
            update(a,b,delta),update(c+1,b,-delta);
            update(a,d+1,-delta),update(c+1,d+1,delta);
        }
        else printf("%d\n",sum(c,d)-sum(a-1,d)-sum(c,b-1)+sum(a-1,b-1));
    }
    return 0;
}
```

## æ±‚é€†åºå¯¹(ç¦»æ•£åŒ–)

å¦‚æœé‡åˆ°ç›¸åŒçš„æ•°å­—ï¼Œç¦»æ•£åŒ–æ—¶ï¼Œè®©å…ˆå‡ºç°çš„æ›´å°
æŠŠæ•°å­—çœ‹æˆæ ‘çŠ¶æ•°ç»„çš„ä¸‹æ ‡ã€‚æ¯å¤„ç†ä¸€ä¸ªæ•°å­—ï¼Œå°±æŠŠä¸‹æ ‡å¯¹åº”å…ƒç´ å€¼åŠ 1ï¼Œç»Ÿè®¡å‰ç¼€å’Œå°±æ˜¯é€†åºå¯¹çš„æ•°é‡

```c++
#include<iostream>
#include<cstring>
#include<algorithm>

using namespace std;
typedef long long LL;
const int N=5e5+5;
int tr[N],r[N],n;
int p[N];
int lowbit(int x)
{
    return x&(-x);
}
void update(int x,int d)
{
    for(int i=x;i<=n;i+=lowbit(i))
        tr[i]+=d;
}
LL sum(int x)
{
    LL res=0;
    while(x>0)
    {
        res+=tr[x];
        x-=lowbit(x);
    }
    return res;
}
void lisanhua(int a[])
{
    for(int i=1;i<=n;i++)p[i]=i;
    sort(p+1,p+1+n,[&](int x,int y)
    {
        if(a[x]==a[y])return x<y;
        return a[x]<a[y];
    });
    for(int i=1;i<=n;i++)a[p[i]]=i;
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)scanf("%d",&r[i]);
    lisanhua(r);
    LL ans=0;
    for(int i=n;i>0;i--)
    {
        update(r[i],1);
        ans+=sum(r[i]-1);
    }
    printf("%lld\n",ans);
    return 0;
}

```

# çº¿æ®µæ ‘ï¼ˆtxy)



# çº¿æ®µæ ‘

<img src="C:\Users\ZA\Desktop\9FX}HI8`1~XJA8C6_V8%K8R.png" alt="./" style="zoom:25%;" />

çº¿æ®µæ ‘æ¯å±‚ç»“ç‚¹åªä¼šé€‰æ‹©ä¸¤æ¬¡ï¼Œç”±äºåŒºé—´æ˜¯è¿ç»­çš„ï¼Œå¦‚æœé€‰æ‹©äº†ä¸‰æ¬¡ï¼Œé‚£ä¹ˆä¸­é—´çš„ç»“ç‚¹ä¼šå’Œä»–ä¸€ä¸ªç›¸é‚»çš„ç»“ç‚¹å˜æˆçˆ¶äº²çš„ç»“ç‚¹ï¼Œä»è€Œå˜æˆä¸Šä¸€å±‚ç»“ç‚¹äº†ã€‚

çº¿æ®µæ ‘ä¸­ç©ºé—´å¼€4å€

å¯¹äºé•¿ä¸º nçš„åºåˆ—ï¼Œæ˜¾ç„¶ä»¥å…¶æ„å»ºçš„çº¿æ®µæ ‘æœ‰ nä¸ªå¶å­èŠ‚ç‚¹ï¼Œæ­¤æ—¶çº¿æ®µæ ‘é«˜åº¦ä¸º$$k = [\log_2n]+1$$

è‡³å¤šæœ‰$$2^kâˆ’1$$ ä¸ªç»“ç‚¹ï¼Œå³æœ‰$$2^{[\log_2n]+1}-1$$ä¸ªç»“ç‚¹ï¼Œå½“$$log_2n$$ä¸ºæ•´æ•°æ—¶ï¼Œç»“ç‚¹æ•°ä¸º$$2n-1$$ï¼Œå½“$$log_2n$$ä¸ä¸ºæ•´æ•°æ—¶ï¼Œç»“ç‚¹æ•°ä¸º$$2^{[\log_2n]+2}-1$$ï¼Œå³$$4n-1$$ã€‚

çº¿æ®µæ ‘æ ‡å· å·¦å„¿å­ä¸ºçˆ¶äº²å·ç ä¹˜2ï¼Œå³å„¿å­ä¸ºçˆ¶äº²å·ç ä¹˜2åŠ 1

ç¬¬ä¸€å±‚ä¸º    1 

ç¬¬äºŒå±‚ä¸º   2 3 

ç¬¬ä¸‰å±‚ä¸º4 5 6 7

åŒºé—´ä¿®æ”¹ä¸­ä¸ºä»€ä¹ˆè¦åŠ v[i]

v[i]è¡¨ç¤ºçº¿æ®µæ ‘é€’å½’çš„æœ€ç»ˆåŒºé—´æ¯ä¸ªæ•°éƒ½è¦åŠ kï¼Œå¦‚æœè¿˜èƒ½å¾€ä¸‹é€’å½’ï¼Œè¿™æ ·ä¼šæµªè´¹æ—¶é—´ï¼Œäºæ˜¯æˆ‘ç”¨ä¸€ä¸ªv[i]è¡¨ç¤ºä¸‹é¢ç»“ç‚¹éƒ½è¦åŠ v[i]ï¼›

å› æ­¤f[k]æ¯æ¬¡éƒ½åŠ äº†å…¨éƒ¨ä¿®æ”¹å€¼ï¼Œä½†æ˜¯åœ¨æœ€ç»ˆåŒºé—´æ˜¯ä¸åŠ çš„ï¼Œè¿™æ—¶å€™è¦ç”¨åˆ°v[i]ã€‚

v[i]ä¸ºå½“å‰ç»“ç‚¹å…¨éƒ¨åŠ äº†kï¼Œå¹¶ä¸”ä¸‹é¢ç»“ç‚¹ä¹ŸåŠ kï¼Œf[i]å½“å‰ç»“ç‚¹kæˆ‘å·²ç»å…¨éƒ¨åŠ ä¸Šå»äº†ï¼Œä½†æ˜¯ä¸‹é¢ç»“ç‚¹åŠ æ²¡åŠ ä¸çŸ¥é“ã€‚v[i]æ ‡è®°ä¸‹é¢æ‰€æœ‰ç»“ç‚¹éƒ½è¦åŠ kï¼Œç”¨æ ‡è®°ä»£æ›¿äº†é€’å½’ã€‚

å‡½æ•°ä¸­kä¸ºå½“å‰æŸ¥è¯¢ç»“ç‚¹å·ï¼Œä¸€å¼€å§‹ä»é¡¶ç‚¹å¼€å§‹æŸ¥è¯¢ï¼Œé»˜è®¤ä¸º1ï¼Œlrä¸ºç»“ç‚¹è¡¨ç¤ºçš„åŒºé—´é»˜è®¤ä¸ºï¼ˆ1ï¼Œn),

æ ‡è®°ä¸‹æ”¾

ç”±äºv[k]è¡¨ç¤ºå½“å‰æ ‘çš„ç»“ç‚¹ä»¥åŠå­å­™ç»“ç‚¹éƒ½è¦åŠ v[k]ï¼Œé‚£ä¹ˆå¯ä»¥æŠŠå½“å‰ç»“ç‚¹çš„v[k]åŠ ä¸Šå»ï¼Œç„¶åå½“å‰ç»“ç‚¹çš„v[k]æ¸…é›¶ï¼Œå­ç»“ç‚¹çš„v[k]åŠ ä¸Šçˆ¶ç»“ç‚¹çš„v[k]ã€‚

##### å»ºæ ‘

```c++
void bulidtree(int k,int l,int r)//æ ‡å·ä¸º1çš„ç‚¹çš„åŒºé—´å¼€å§‹å»ºæ ‘bulidtree(1,1,n)
{
    v[k] = 0;
	if(l == r)
	{
		f[k] = a[l];//ä¸¤ç«¯å’Œç›¸åŒåŒºé—´å’Œç­‰äºæœ¬èº«
		return;
	}
	int m = (l + r)>>1;
	bulidtree(k + k, l, m);
	bulidtree(k + k + 1, m + 1, r);
	f[k] = f[k + k + 1] + f[k + k];
}
```

##### å•ç‚¹ä¿®æ”¹(æŸä¸ªæ•°å€¼æ”¹å˜)

```cpp
void add(int k,int l,int r,int x,int y)//kç»“ç‚¹å¯¹åº”çš„åŒºé—´ä¸Šçš„ä¸‹æ ‡ä¸ºxçš„æ•°ä¸Šï¼Œxè‚¯å®šåœ¨lrä¹‹é—´
{
	f[k]+=y;//åŒ…å«ä¸‹æ ‡çš„xçš„åŒºé—´ä¸­çš„ç»“ç‚¹éƒ½è¦åŠ y;
	if(l == r)
		return;
	int m = (l+r)>>1;
	if(x <= m)
	{
		add(k + k,l,m,x,y);
	}
	else
	{
		add(k + k + 1,m + 1,r,x,y);
	}
	
}
```

##### å•ç‚¹æŸ¥è¯¢(æŸ¥è¯¢æŸä¸ªæ•°å€¼)(å¯ä»¥å¥—ç”¨å¤šç‚¹)

```c++
long long chaxun(int k,int l,int r,int x,int p)
{
	p += v[k];
	if(l == r)
	{
		return f[k]+p;
	}
	int m = (l + r)>>1;
	if(x <= m)
	{
		return chaxun(k + k, l, m, x, p);
	}
	else
	{
		return chaxun(k + k + 1, m + 1, r, x, p);
	}
}
```

##### åŒºé—´ä¿®æ”¹(åŒºé—´é‡Œçš„æ•°å€¼å‘ç”Ÿæ”¹å˜)

```c++
void insert(int k,int l,int r,int x,int y,long long z)//l-råŒºé—´é‡Œçš„xyåŒºé—´åŠ ä¸Šz,kä¸ºå½“å‰æŸ¥è¯¢åŒºé—´
{
	if(l == x&&r == y)
	{
		v[k] += z;
		return;
	}
	f[k] += (y - x + 1) * z;//åŒºé—´é•¿åº¦æ¯ä¸ªåŠ z
	int m = (l + r)>>1;
	if(y <= m)
	{
		insert(k + k, l, m, x, y, z);
	}
	else
	{
		if(x > m)
		{
			insert(k + k + 1, m + 1, r, x, y, z);
		}
		else
		{
			insert(k + k, l, m, x, m, z);
			insert(k + k + 1, m + 1, r, m + 1,y,z);
		}
	}
}
```

æ ‡è®°ä¸‹ä¼ 

```c++
void insert(int k,int l,int r,int x,int y,long long z)//l-råŒºé—´é‡Œçš„xyåŒºé—´åŠ ä¸Šz,kä¸ºå½“å‰æŸ¥è¯¢åŒºé—´
{
	if(l == x && r == y)
	{
		v[k] += z;
		return;
	}
	if(v[k])
	{
		v[k + k] += v[k];
		v[k + k + 1] += v[k];
		v[k] = 0;
	}
	int m = (l + r)>>1;
	if(y <= m)
	{
		insert(k + k, l, m, x, y, z);
	}
	else
	{
		if(x > m)
		{
			insert(k + k + 1, m + 1, r, x, y, z);
		}
		else
		{
			insert(k + k, l, m, x, m, z);
			insert(k + k + 1, m + 1, r, m + 1, y, z);
		}
	}
	//æ ‡è®°å›æ”¶ 
	f[k] = f[k + k] + v[k + k] * (m - l + 1) + f[k + k + 1] + v[k + k + 1] * (r - m);
}
```



##### åŒºé—´æŸ¥è¯¢

1.ä¸å¸¦v[i]

```c++
long long calc(int k,int l,int r,int s,int t)//kç»“ç‚¹ä»£è¡¨lrçš„åŒºé—´ï¼Œæ±‚stçš„å’Œ
{
	if(l==s && r==t)
	{
		return f[k];
	}
	int m = (l + r)>>1;
	if(t <= m)
	{
		return calc(k + k, l, m, s, t);
	}
	else
	{
		if(s > m)
			return calc(k + k + 1, m + 1, r, s, t);
		else
			return calc(k + k, l, m, s, m) + calc(k + k + 1, m + 1, r, m + 1, t);	
	}
}
```

2.å¸¦v[i]

```c++
long long  calc(int k,int l,int r,int x,int y,long long p)//kç»“ç‚¹ä»£è¡¨lrçš„åŒºé—´ï¼Œæ±‚stçš„å’Œ
{
	p += v[k];
	if(l == x&&r == y)
	{
		return p * (r - l + 1) + f[k];
	}
	int m = (l + r)>>1;
	if(y <= m)
	{
		return calc(k + k, l, m, x, y, p);
	}
	else
	{
		if(x > m)
			return calc(k + k + 1, m + 1, r, x, y, p);
		else
			return calc(k + k, l, m, x, m, p) + calc_1(k + k + 1, m + 1, r, m+1, y, p);	
	}
}
```

3.æ ‡è®°ä¸‹ä¼ 

```c++
long long calc(int k,int l,int r,int s,int t)//kç»“ç‚¹ä»£è¡¨lrçš„åŒºé—´ï¼Œæ±‚stçš„å’Œ
{
	if(l==s&&r==t)
	{
		return f[k] + v[k] * (r - l + 1);
	}
	if(v[k])//æ ‡è®°ä¸‹ç§»
	{
		v[k + k] += v[k];
		v[k + k + 1] += v[k];
		v[k] = 0;
	}
	int m = (l + r)>>1;
	long long res = 0;//è®°å½•æŸ¥è¯¢ç»“æœ,ä¸èƒ½ç›´æ¥return,å› ä¸ºæ²¡æœ‰ä¿®æ”¹fçš„å€¼
	if(t <= m)
	{
		res = calc(k + k,l,m,s,t);
	}
	else
	{
		if(s > m) 
			res = calc(k + k + 1, m + 1, r, s, t);
		else
			res = calc(k + k, l, m, s, m) + calc(k + k + 1, m + 1, r, m+1, t);	
	}
	f[k] = f[k + k] + v[k + k] * (m - l + 1) + f[k + k + 1] + v[k + k + 1] * (r - m);
	return res;//fä¿®æ”¹å®Œåreturnç»“æœ
}
```

åœ¨insertä¸­å·²ç»æ ‡è®°ä¸‹ä¼ äº†ï¼Œåœ¨calcä¸­ä¹Ÿéœ€è¦ä¸‹ä¼ ï¼Œå› ä¸ºinsertä¸­çš„æœ€åä¸€ç»“ç‚¹å¹¶æ²¡æœ‰æ‰§è¡Œä¸‹ä¼ æ“ä½œã€‚

æ ‡è®°ä¸‹ç§»ä¸€èˆ¬è‡ªå·±å†™å‡½æ•°ã€‚

# ä¸»å¸­æ ‘

ä¸»è¦åº”ç”¨äºæ±‚ç¬¬kå°(å¤§)é—®é¢˜

## é¢˜ç›®æè¿°

å¦‚é¢˜ï¼Œç»™å®š $n$ ä¸ªæ•´æ•°æ„æˆçš„åºåˆ— $a$ï¼Œå°†å¯¹äºæŒ‡å®šçš„é—­åŒºé—´ $[l, r]$ æŸ¥è¯¢å…¶åŒºé—´å†…çš„ç¬¬ $k$ å°å€¼ã€‚

## è¾“å…¥æ ¼å¼

ç¬¬ä¸€è¡ŒåŒ…å«ä¸¤ä¸ªæ•´æ•°ï¼Œåˆ†åˆ«è¡¨ç¤ºåºåˆ—çš„é•¿åº¦ $n$ å’ŒæŸ¥è¯¢çš„ä¸ªæ•° $m$ã€‚  
ç¬¬äºŒè¡ŒåŒ…å« $n$ ä¸ªæ•´æ•°ï¼Œç¬¬ $i$ ä¸ªæ•´æ•°è¡¨ç¤ºåºåˆ—çš„ç¬¬ $i$ ä¸ªå…ƒç´  $a_i$ã€‚   
æ¥ä¸‹æ¥ $m$ è¡Œæ¯è¡ŒåŒ…å«ä¸‰ä¸ªæ•´æ•° $ l, r, k$ , è¡¨ç¤ºæŸ¥è¯¢åŒºé—´ $[l, r]$ å†…çš„ç¬¬ $k$ å°å€¼ã€‚

## è¾“å‡ºæ ¼å¼

å¯¹äºæ¯æ¬¡è¯¢é—®ï¼Œè¾“å‡ºä¸€è¡Œä¸€ä¸ªæ•´æ•°è¡¨ç¤ºç­”æ¡ˆã€‚

## æ ·ä¾‹ #1

### æ ·ä¾‹è¾“å…¥ #1

```
5 5
25957 6405 15770 26287 26465 
2 2 1
3 4 1
4 5 1
1 2 2
4 4 1
```

### æ ·ä¾‹è¾“å‡º #1

```
6405
15770
26287
25957
26287
```

## æ•°æ®è§„æ¨¡ä¸çº¦å®š

- å¯¹äº $20\%$ çš„æ•°æ®ï¼Œæ»¡è¶³ $1 \leq n,m \leq 10$ã€‚
- å¯¹äº $50\%$ çš„æ•°æ®ï¼Œæ»¡è¶³ $1 \leq n,m \leq 10^3$ã€‚
- å¯¹äº $80\%$ çš„æ•°æ®ï¼Œæ»¡è¶³ $1 \leq n,m \leq 10^5$ã€‚
- å¯¹äº $100\%$ çš„æ•°æ®ï¼Œæ»¡è¶³ $1 \leq n,m \leq 2\times 10^5$ï¼Œ$0\le a_i \leq 10^9$ï¼Œ$1 \leq l \leq r \leq n$ï¼Œ$1 \leq k \leq r - l + 1$ã€‚

```c++
#include<iostream>
#include<cstring>
#include<algorithm>

using namespace std;
const int N=2e5+10;
int cnt=0;
int a[N],b[N],root[N];
struct
{
    int l,r,sum;
}tr[N<<5];
int build(int pl,int pr)
{
    int p=++cnt;
    tr[p].sum=0;
    int mid=pl+pr>>1;
    if(pl<pr)
    {
        tr[p].l=build(pl,mid);
        tr[p].r=build(mid+1,pr);
    }
    return p;
}
int update(int pre,int pl,int pr,int x)
{
    int p=++cnt;
    tr[p].l=tr[pre].l;
    tr[p].r=tr[pre].r;
    tr[p].sum=tr[pre].sum+1;
    int mid=pl+pr>>1;
    if(pl<pr)
    {
        if(x<=mid)tr[p].l=update(tr[pre].l,pl,mid,x);
        else tr[p].r=update(tr[pre].r,mid+1,pr,x);
    }
    return p;
}
int query(int u,int v,int pl,int pr,int k)
{
    if(pl==pr)return pl;
    int x=tr[tr[v].l].sum-tr[tr[u].l].sum;
    int mid=pl+pr>>1;
    if(pl<pr)
    {
        if(x>=k)return query(tr[u].l,tr[v].l,pl,mid,k);
        else return query(tr[u].r,tr[v].r,mid+1,pr,k-x);
    }
}
int main()
{
    int n,m,k;
    cin>>n>>m;
    for(int i=1;i<=n;i++)cin>>a[i],b[i]=a[i];
    sort(b+1,b+n+1);
    int size=unique(b+1,b+n+1)-b-1;
    root[0]=build(1,size);
    for(int i=1;i<=n;i++)
    {
        int x=lower_bound(b+1,b+1+size,a[i])-b;
        root[i]=update(root[i-1],1,size,x);
    }
    while(m--)
    {
        int l,r;
        cin>>l>>r>>k;
        int idx=query(root[l-1],root[r],1,size,k);
        cout<<b[idx]<<endl;
    }
    return 0;
}
```

## TTM - To the moon


ä¸€ä¸ªé•¿åº¦ä¸º $N$ çš„æ•°ç»„ $\{A\}$ï¼Œ$4$ ç§æ“ä½œ ï¼š

- `C l r d`ï¼šåŒºé—´ $[l,r]$ ä¸­çš„æ•°éƒ½åŠ  $d$ ï¼ŒåŒæ—¶å½“å‰çš„æ—¶é—´æˆ³åŠ  $1$ã€‚

- `Q l r`ï¼šæŸ¥è¯¢å½“å‰æ—¶é—´æˆ³åŒºé—´ $[l,r]$ ä¸­æ‰€æœ‰æ•°çš„å’Œ ã€‚

- `H l r t`ï¼šæŸ¥è¯¢æ—¶é—´æˆ³ $t$ åŒºé—´ $[l,r]$ çš„å’Œ ã€‚

- `B t`ï¼šå°†å½“å‰æ—¶é—´æˆ³ç½®ä¸º $t$ ã€‚

ã€€ã€€æ‰€æœ‰æ“ä½œå‡åˆæ³• ã€‚

psï¼šåˆšå¼€å§‹æ—¶æ—¶é—´æˆ³ä¸º $0$

è¾“å…¥æ ¼å¼ï¼Œä¸€è¡Œ $N$ å’Œ $M$ï¼Œæ¥ä¸‹æ¥ $M$ è¡Œæ¯è¡Œä¸€ä¸ªæ“ä½œ

è¾“å‡ºæ ¼å¼ï¼šå¯¹æ¯ä¸ªæŸ¥è¯¢è¾“å‡ºä¸€è¡Œè¡¨ç¤ºç­”æ¡ˆ

æ•°æ®ä¿è¯ï¼š$1\le N,M\le 10^5$ï¼Œ$|A_i|\le 10^9$ï¼Œ$1\le l \le r \le N$ï¼Œ$|d|\le10^4$ã€‚åœ¨åˆšå¼€å§‹æ²¡æœ‰è¿›è¡Œæ“ä½œçš„æƒ…å†µä¸‹æ—¶é—´æˆ³ä¸º $0$ï¼Œä¸”ä¿è¯ `B` æ“ä½œä¸ä¼šè®¿é—®åˆ°æœªæ¥çš„æ—¶é—´æˆ³ã€‚

ç”± @bztMinamoto @yzy1 æä¾›ç¿»è¯‘

### é¢˜ç›®æè¿°

### è¾“å…¥æ ¼å¼

```
n m
A1 A2 ... An
... (here following the m operations. )
```

### è¾“å‡ºæ ¼å¼

`... (for each query, simply print the result. )`

### æ ·ä¾‹ #1

#### æ ·ä¾‹è¾“å…¥ #1

```
10 5
1 2 3 4 5 6 7 8 9 10
Q 4 4
Q 1 10
Q 2 4
C 3 6 3
Q 2 4
```

#### æ ·ä¾‹è¾“å‡º #1

```
4
55
9
15
```

### æ ·ä¾‹ #2

#### æ ·ä¾‹è¾“å…¥ #2

```
2 4
0 0
C 1 1 1
C 2 2 -1
Q 1 2
H 1 2 1
```

#### æ ·ä¾‹è¾“å‡º #2

```
0
1
```

å¦‚æœæ²¡æœ‰æ—¶é—´tåˆ™è¯´æ ‡å‡†çº¿æ®µæ ‘æ¨¡æ¿é¢˜ï¼Œæœ‰äº†tåªéœ€æŒ‰ç…§ä¸»å¸­æ ‘æ¨¡æ¿æ¥å³å¯ï¼Œæ³¨æ„å› ä¸ºæ˜¯åŠ¨æ€å¼€ç‚¹ï¼Œæ ‡è®°ä¸‹ä¼ ä¼šæ•ˆç‡å¤§å¹…é™ä½è€ƒè™‘æ ‡è®°æ°¸ä¹…åŒ–ï¼Œå³åªéœ€åœ¨æŸ¥è¯¢æ—¶æŠŠè·¯å¾„ä¸Šçš„æ ‡è®°ä¾æ¬¡åŠ å…¥ç­”æ¡ˆ

```c++
#include<iostream>
#include<cstring>
#include<algorithm>

using namespace std;
typedef long long ll;
const int N=1e5+10;
struct Node
{
    int l,r;
    ll sum;
    int tg;
}tr[N<<5];
int root[N];
int cnt,now;
int build(int l,int r)
{
    int p=++cnt;
    tr[p].tg=0;
    if(l==r)
    {
        scanf("%lld",&tr[p].sum);
        return p;
    }
    int mid=l+r>>1;
    tr[p].l=build(l,mid);
    tr[p].r=build(mid+1,r);
    tr[p].sum=tr[tr[p].l].sum+tr[tr[p].r].sum;
    return p;
}
int update(int pre,int pl,int pr,int l,int r,int val)
{
    int p=++cnt;
    tr[p]=tr[pre];
    tr[p].sum+=(r-l+1)*val;
    if(l==pl&&r==pr)
    {
        tr[p].tg+=val;//æ ‡è®°ç”¨æ¥æŸ¥è¯¢å­åŒºé—´
        return p;
    }
    int mid=pl+pr>>1;
    if(r<=mid)tr[p].l=update(tr[pre].l,pl,mid,l,r,val);
    else if(l>mid)tr[p].r=update(tr[pre].r,mid+1,pr,l,r,val);
    else
    {
        tr[p].l=update(tr[pre].l,pl,mid,l,mid,val);
        tr[p].r=update(tr[pre].r,mid+1,pr,mid+1,r,val);
    }
    return p;
}
ll query(int t,int pl,int pr,int l,int r)
{
    if(l==pl&&r==pr)return tr[t].sum;
    ll res=1ll*(r-l+1)*tr[t].tg;
    int mid=pl+pr>>1;
    if(r<=mid)return query(tr[t].l,pl,mid,l,r)+res;
    else if(l>mid)return query(tr[t].r,mid+1,pr,l,r)+res;
    else return query(tr[t].l,pl,mid,l,mid)+query(tr[t].r,mid+1,pr,mid+1,r)+res;
}
int main()
{
    int n,m;
    cin>>n>>m;
    cnt=0,now=0;
    root[0]=build(1,n);
    char c[3];
    int l,r,t,x;
    while(m--)
    {
        scanf("%s",c);
        if(c[0]=='Q')
        {
            scanf("%d %d",&l,&r);
            printf("%lld\n",query(root[now],1,n,l,r));
        }
        else if(c[0]=='H')
        {
            scanf("%d %d %d",&l,&r,&t);
            printf("%lld\n",query(root[t],1,n,l,r));
        }
        else if(c[0]=='C')
        {
            scanf("%d %d %lld",&l,&r,&x);
            root[now+1]=update(root[now],1,n,l,r,x);
            now++;
        }
        else
        {
            scanf("%d",&t);
            now=t;
        }
    }
    return 0;
}
```

# æ ‘çš„é‡å¿ƒ

å®šä¹‰ï¼šæ ‘çš„é‡å¿ƒï¼šé‡å¿ƒæ˜¯æŒ‡æ ‘ä¸­çš„ä¸€ä¸ªç»“ç‚¹ï¼Œå¦‚æœå°†è¿™ä¸ªç‚¹åˆ é™¤åï¼Œå‰©ä½™å„ä¸ªè¿é€šå—ä¸­ç‚¹æ•°çš„æœ€å¤§å€¼æœ€å°ï¼Œé‚£ä¹ˆè¿™ä¸ªç‚¹å°±æ˜¯è¿™æ£µæ ‘çš„é‡å¿ƒã€‚

ç”¨æ•°ç»„då­˜å‚¨ä»¥è¯¥èŠ‚ç‚¹ä¸ºæ ¹çš„å­æ ‘çš„èŠ‚ç‚¹æ•°ï¼Œåˆ™éå†æ¯ä¸ªèŠ‚ç‚¹æ—¶å¯ä»¥æ±‚å‡ºæ¯ä¸ªå„¿å­èŠ‚ç‚¹çš„èŠ‚ç‚¹æ•°ï¼Œå–å‡ºä¸Šè¿°æ•°çš„æœ€å¤§å€¼ï¼Œç”¨æ€»ç»“ç‚¹æ•°å‡å»ä¸Šè¿°æ•°æ±‚å’Œå†å‡ä¸€å°±æ˜¯æœ€åä¸€ä¸ªè¿é€šå—çš„èŠ‚ç‚¹æ•°ï¼Œå–maxå³å¯

ä¸‹é¢çš„ä»£ç è¾“å‡ºäº†å¯èƒ½ä¸ºæ ‘çš„é‡å¿ƒçš„èŠ‚ç‚¹å¹¶ä»å°åˆ°å¤§è¾“å‡º

```c++
#include<iostream>
#include<algorithm>
#include<cstring>

using namespace std;
const int N=5e4+10;
int h[N],e[N<<1],ne[N<<1],idx;
void init()
{
    memset(h,-1,sizeof(h));
}
void add(int a,int b)
{
    e[idx]=b,ne[idx]=h[a],h[a]=idx++;
}
int n;
int d[N],ans[N],num=0,maxnum=1e9;
void dfs(int u,int fa)
{
    d[u]=1;
    int tmp=0;
    for(int i=h[u];~i;i=ne[i])
    {
        int v=e[i];
        if(v==fa)continue;
        dfs(v,u);
        d[u]+=d[v];
        // printf("%d %d %d %d\n",u,v,d[u],d[v]);
        tmp=max(tmp,d[v]);
    }
    tmp=max(tmp,n-d[u]);
    // if(u==2||u==3)printf("%d %d\n",u,tmp);
    if(tmp<maxnum)
    {
        maxnum=tmp;
        num=0;
        ans[++num]=u;
    }
    else if(tmp==maxnum)ans[++num]=u;
}
int main()
{
    init();
    cin>>n;
    for(int i=1;i<n;i++)
    {
        int u,v;
        cin>>u>>v;
        add(u,v),add(v,u);
    }
    dfs(1,0);
    sort(ans+1,ans+1+num);
    // cout<<d[1]<<endl;
    for(int i=1;i<=num;i++)printf("%d ",ans[i]);
    return 0;
}
```

# LCA

åŸºäºå€å¢æ³•çš„LCA
å®šä¹‰

$f[x][i]$ä¸º$x$èŠ‚ç‚¹çš„ç¬¬$2^i$ä¸ªç¥–å…ˆï¼Œ$f[x][0]$ä¸º$x$çš„çˆ¶èŠ‚ç‚¹
åˆ™æœ‰é€’æ¨å…³ç³»
$f[x][i]=f[f[x][i-1]][i-1]$

ä¸‹é¢ä»£ç è¾“å…¥ä¸¤ä¸ªèŠ‚ç‚¹è¾“å‡ºä»–ä»¬çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ

```c++
#include<iostream>
#include<cstring>
#include<algorithm>

using namespace std;
const int N=5e5+10;
int h[N],e[N<<1],ne[N<<1],idx;
int f[N][20],deep[N];
void add(int a,int b)
{
    e[idx]=b,ne[idx]=h[a],h[a]=idx++;
} 
void init()
{
    memset(h,-1,sizeof h);
    idx=0;
}
void dfs(int x,int fa)
{
    deep[x]=deep[fa]+1;
    f[x][0]=fa;
    for(int i=1;(1<<i)<=deep[x];i++)
        f[x][i]=f[f[x][i-1]][i-1];
    for(int i=h[x];~i;i=ne[i])
    {
        if(e[i]!=fa)
            dfs(e[i],x);
    }
}
int LCA(int x,int y)
{
    if(deep[x]<deep[y])swap(x,y);
    for(int i=19;i>=0;i--)
        if(deep[x]-(1<<i)>=deep[y])
            x=f[x][i];
    if(x==y)return y;
    for(int i=19;i>=0;i--)
    {
        if(f[x][i]!=f[y][i])
        {
            x=f[x][i],y=f[y][i];
        }
    }
    return f[x][0];
}
int main()
{
    init();
    int n,m,root;
    cin>>n>>m>>root;
    for(int i=1;i<n;i++)
    {
        int u,v;
        cin>>u>>v;
        add(u,v),add(v,u);
    }
    dfs(root,0);
    while(m--)
    {
        int x,y;
        cin>>x>>y;
        cout<<LCA(x,y)<<endl;
    }
    return 0;
}
```

## æ ‘ä¸Šå·®åˆ†



# å¹¶æŸ¥é›†

```cpp
const int N = 2e5 + 9;
int s[N]; // é›†
int rank[N]; // æƒå€¼ï¼Œè®°å½•å½“å‰èŠ‚ç‚¹åˆ°æ ¹èŠ‚ç‚¹çš„è·ç¦»

int ans;

void init_set() {
    for(int i = 0; i <= N; ++i) {
        s[i] = i;
        rank[i] = 0;
    }
}

int find_set(int x) {
    if(x != s[x]) {
        int t = s[x];
        s[x] = find_set(s[x]); // è·¯å¾„å‹ç¼©
        rank[x] += rank[t];
    }
    return s[x];
}

void merge_set(int a, int b, int v) {
    int root_a = find_set(a);
    int root_b = find_set(b);
    if(root_a == root_b) {
        if(rank[a] - rank[b] != v) {
            ++ans;
        }
    } else {
        s[root_a] = root_b; // åˆå¹¶
        rank[root_a] = rank[b] - rank[a] + v;
    }
}
```

# ç¦»æ•£åŒ–ç»“æ„

```cpp
struct data {
    int val; // å€¼
    int id; // ä½ç½®

    bool operator<(const data& other) {
        return this->val < other.val;
    }
};
```

# è´Ÿè¿›åˆ¶

ä¾‹å¦‚-15 çš„-2è¿›åˆ¶ä¸º110001//8+4+2+1//1111

è§£ç­”æ­¥éª¤ï¼š

-15 /-2 = 8â€¦â€¦1

8 /-2 = -4â€¦â€¦0

-4/-2=2â€¦â€¦0

2/-2=-1â€¦â€¦0

-1/-2=1â€¦â€¦1

1/-2=0â€¦â€¦1

å¯¹äºç¬¬ä¸€é¡¹-15/-2ä¸ºä»€ä¹ˆä¸èƒ½ä¸º7â€¦â€¦-1ï¼Œ**å› ä¸ºä½™æ•°ä¸èƒ½ä¸ºè´Ÿæ•°ï¼Œä½†æ˜¯åœ¨è®¡ç®—æœºä¸­ç»“æœæ˜¯è¿™æ ·çš„ï¼š-15%-2 = -1,-15/-2 = 7**ï¼Œä¸æ»¡è¶³è¿ç®—è§„åˆ™ã€‚æˆ‘ä»¬åªéœ€è¦å°†å•†+1ï¼Œä½™æ•°-é™¤æ•°å³å¯ï¼Œå› ä¸ºä½™æ•°ï¼ˆç»å¯¹å€¼ï¼‰ä¸€å®šå°äºé™¤æ•°ï¼Œæ‰€ä»¥è¿™æ ·å°±å¯ä»¥å°†ä½™æ•°è£…æ¢ä¸ºæ­£æ•°ã€‚

å•†\*é™¤æ•°+ä½™æ•°=è¢«é™¤æ•°

å•†\*é™¤æ•°+é™¤æ•°+ä½™æ•°-é™¤æ•°=è¢«é™¤æ•°

(å•†+1ï¼‰\*é™¤æ•°+ï¼ˆä½™æ•°-é™¤æ•°ï¼‰=è¢«é™¤æ•°

7*(-2)-1 = -15

(7+1)*(-2)+1 = -15

å¯¹äºåŸæœ¬ä½™æ•°æ˜¯æ­£æ•°çš„ä¸èƒ½ä½¿ç”¨ï¼Œæ­¤å¼å­ä¼šæ”¹å˜å•†çš„ç»“æœå’Œä½™æ•°ç»“æœï¼Œå•†ç»“æœä¸ºå•†+1ï¼Œ

ä½™æ•°ç»“æœä¸ºä½™æ•°-é™¤æ•°

[P1017 [NOIP2000 æé«˜ç»„\] è¿›åˆ¶è½¬æ¢ - æ´›è°· | è®¡ç®—æœºç§‘å­¦æ•™è‚²æ–°ç”Ÿæ€ (luogu.com.cn)](https://www.luogu.com.cn/problem/P1017)

```
è¾“å…¥æ ¼å¼

ç¬¬ä¸€ä¸ªæ˜¯åè¿›åˆ¶æ•° nã€‚ç¬¬äºŒä¸ªæ˜¯è´Ÿè¿›åˆ¶æ•°çš„åŸºæ•° ğ‘…ã€‚

è¾“å‡ºæ ¼å¼

è¾“å‡ºæ­¤è´Ÿè¿›åˆ¶æ•°åŠå…¶åŸºæ•°ï¼Œè‹¥æ­¤åŸºæ•°è¶…è¿‡ 10ï¼Œåˆ™å‚ç…§ 16 è¿›åˆ¶çš„æ–¹å¼å¤„ç†ã€‚
```

```c++
#include <bits/stdc++.h>
using namespace  std;
char a[]= {'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T'
			,'U','V','W','X','Y','Z'};
int main ()
{
	int n;
	cin >>n;
	int chushu,shang,yushu;
	int r;
	cin >> r;
	chushu = n;
	shang = 1;
	char b[100000];
	int i = 0;
	while(shang !=0)
	{
		
		shang = chushu / r;
		yushu = chushu % r;
		if(yushu < 0 )//ä½™æ•°å°äº0ï¼Œæ”¹å˜å•†å’Œä½™æ•°çš„å€¼ã€‚
		{
			shang++;
			yushu=yushu-r;
		}
		if(yushu >= 10)
			b[i] = a[yushu-10];
		else
			b[i] = yushu+'0';
		i++;
		chushu = shang;
	}
	cout<<n<<"=";
	for(int j = i - 1;j >=0;j--)
	{
		
		cout<<b[j];
	}
	cout<<"(base"<<r<<")";
	return 0;
}

```

# é«˜ç²¾åº¦

### é«˜ç²¾åº¦åŠ æ³•

ä¼ å…¥å‚æ•°çº¦å®šï¼šä¼ å…¥å‚æ•°å‡ä¸ºstringç±»å‹ï¼Œè¿”å›å€¼ä¸ºstringç±»å‹

ç®—æ³•æ€æƒ³ï¼šå€’ç½®ç›¸åŠ å†è¿˜åŸã€‚

```c++
string add(string a,string b)//åªé™ä¸¤ä¸ªéè´Ÿæ•´æ•°ç›¸åŠ 
{
    const int L=1e5;
    string ans;
    int na[L]={0},nb[L]={0};
    int la=a.size(),lb=b.size();
    for(int i=0;i<la;i++) na[la-1-i]=a[i]-'0';
    for(int i=0;i<lb;i++) nb[lb-1-i]=b[i]-'0';
    int lmax=la>lb?la:lb;
    for(int i=0;i<lmax;i++) na[i]+=nb[i],na[i+1]+=na[i]/10,na[i]%=10;
    if(na[lmax]) lmax++;
    for(int i=lmax-1;i>=0;i--) ans+=na[i]+'0';
    return ans;
}
```

### é«˜ç²¾åº¦å‡æ³•

ä¼ å…¥å‚æ•°çº¦å®šï¼šä¼ å…¥å‚æ•°å‡ä¸ºstringç±»å‹ï¼Œè¿”å›å€¼ä¸ºstringç±»å‹

ç®—æ³•æ€æƒ³ï¼šå€’ç½®ç›¸å‡å†è¿˜åŸã€‚

```c++
string sub(string a,string b)//åªé™å¤§çš„éè´Ÿæ•´æ•°å‡å°çš„éè´Ÿæ•´æ•°
{
    const int L=1e5;
    string ans;
    int na[L]={0},nb[L]={0};
    int la=a.size(),lb=b.size();
    for(int i=0;i<la;i++) na[la-1-i]=a[i]-'0';
    for(int i=0;i<lb;i++) nb[lb-1-i]=b[i]-'0';
    int lmax=la>lb?la:lb;
    for(int i=0;i<lmax;i++)
    {
        na[i]-=nb[i];
        if(na[i]<0) na[i]+=10,na[i+1]--;
    }
    while(!na[--lmax]&&lmax>0)  ;lmax++;
    for(int i=lmax-1;i>=0;i--) ans+=na[i]+'0';
    return ans;
}
```



### é«˜ç²¾åº¦ä¹˜æ³•

1ï¼‰é«˜ç²¾åº¦ä¹˜é«˜ç²¾åº¦çš„æœ´ç´ ç®—æ³•

1ï¼‰é«˜ç²¾åº¦ä¹˜é«˜ç²¾åº¦çš„æœ´ç´ ç®—æ³•

 

ä¼ å…¥å‚æ•°çº¦å®šï¼šä¼ å…¥å‚æ•°å‡ä¸ºstringç±»å‹ï¼Œè¿”å›å€¼ä¸ºstringç±»å‹

ç®—æ³•æ€æƒ³ï¼šå€’ç½®ç›¸ä¹˜ï¼Œç„¶åç»Ÿä¸€å¤„ç†è¿›ä½ï¼Œå†è¿˜åŸã€‚

```c++
string mul(string a,string b)//é«˜ç²¾åº¦ä¹˜æ³•a,b,å‡ä¸ºéè´Ÿæ•´æ•°
{
    const int L=1e5;
    string s;
    int na[L],nb[L],nc[L],La=a.size(),Lb=b.size();//naå­˜å‚¨è¢«ä¹˜æ•°ï¼Œnbå­˜å‚¨ä¹˜æ•°ï¼Œncå­˜å‚¨ç§¯
    fill(na,na+L,0);fill(nb,nb+L,0);fill(nc,nc+L,0);//å°†na,nb,ncéƒ½ç½®ä¸º0
    for(int i=La-1;i>=0;i--) na[La-i]=a[i]-'0';//å°†å­—ç¬¦ä¸²è¡¨ç¤ºçš„å¤§æ•´å½¢æ•°è½¬æˆiæ•´å½¢æ•°ç»„è¡¨ç¤ºçš„å¤§æ•´å½¢æ•°
    for(int i=Lb-1;i>=0;i--) nb[Lb-i]=b[i]-'0';
    for(int i=1;i<=La;i++)
        for(int j=1;j<=Lb;j++)
        nc[i+j-1]+=na[i]*nb[j];//açš„ç¬¬iä½ä¹˜ä»¥bçš„ç¬¬jä½ä¸ºç§¯çš„ç¬¬i+j-1ä½ï¼ˆå…ˆä¸è€ƒè™‘è¿›ä½ï¼‰
    for(int i=1;i<=La+Lb;i++)
        nc[i+1]+=nc[i]/10,nc[i]%=10;//ç»Ÿä¸€å¤„ç†è¿›ä½
    if(nc[La+Lb]) s+=nc[La+Lb]+'0';//åˆ¤æ–­ç¬¬i+jä½ä¸Šçš„æ•°å­—æ˜¯ä¸æ˜¯0
    for(int i=La+Lb-1;i>=1;i--)
        s+=nc[i]+'0';//å°†æ•´å½¢æ•°ç»„è½¬æˆå­—ç¬¦ä¸²
    return s;
}
```

### é«˜ç²¾åº¦é™¤æ³•

é«˜ç²¾åº¦é™¤å•ç²¾åº¦

ä¼ å…¥å‚æ•°çº¦å®šï¼šä¼ å…¥ç¬¬ä¸€å‚æ•°ä¸ºstringç±»å‹ï¼Œç¬¬äºŒä¸ªä¸ºintå‹ï¼Œè¿”å›å€¼ä¸ºstringç±»å‹

ç®—æ³•æ€æƒ³ï¼š[æ¨¡æ‹Ÿ](https://www.baidu.com/s?wd=æ¨¡æ‹Ÿ&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd)æ‰‹å·¥é™¤æ³•ã€‚

```c++
string div(string a,int b)//é«˜ç²¾åº¦aé™¤ä»¥å•ç²¾åº¦b
{
    string r,ans;
    int d=0;
    if(a=="0") return a;//ç‰¹åˆ¤
    for(int i=0;i<a.size();i++)
    {
            r+=(d*10+a[i]-'0')/b+'0';//æ±‚å‡ºå•†
            d=(d*10+(a[i]-'0'))%b;//æ±‚å‡ºä½™æ•°
    }
    int p=0;
    for(int i=0;i<r.size();i++)
    if(r[i]!='0') {p=i;break;}
    return r.substr(p);
}
```

### é«˜ç²¾åº¦å–æ¨¡

```c++
string div(string a,int b)//é«˜ç²¾åº¦aé™¤ä»¥å•ç²¾åº¦b
{
    string r,ans;
    int d=0;
    if(a=="0") return a;//ç‰¹åˆ¤
    for(int i=0;i<a.size();i++)
    {
            r+=(d*10+a[i]-'0')/b+'0';//æ±‚å‡ºå•†
            d=(d*10+(a[i]-'0'))%b;//æ±‚å‡ºä½™æ•°
    }
    int p=0;
    for(int i=0;i<r.size();i++)
    if(r[i]!='0') {p=i;break;}
    return r.substr(p);
}
```

### é«˜ç²¾åº¦é˜¶ä¹˜

ä¼ å…¥å‚æ•°çº¦å®šï¼šä¼ å…¥å‚æ•°ä¸ºintå‹ï¼Œè¿”å›å€¼ä¸ºstringç±»å‹

ç®—æ³•æ€æƒ³ï¼šé«˜ç²¾åº¦ä¹˜å•ç²¾åº¦çš„ç®€å•è¿ç”¨ã€‚

```c++
string fac(int n)
{
    const int L=100005;
    int a[L];
    string ans;
    if(n==0) return "1";
    fill(a,a+L,0);
    int s=0,m=n;
    while(m) a[++s]=m%10,m/=10;
    for(int i=n-1;i>=2;i--)
    {
        int w=0;
        for(int j=1;j<=s;j++) a[j]=a[j]*i+w,w=a[j]/10,a[j]=a[j]%10;
        while(w) a[++s]=w%10,w/=10;
    }
    while(!a[s]) s--;
    while(s>=1) ans+=a[s--]+'0';
    return ans;
}
```

# å­—ç¬¦ä¸²

## è¿›åˆ¶å“ˆå¸Œ

### BKDRHash

è®¾å®šä¸€ä¸ªè¿›åˆ¶Pï¼Œéœ€è¦è®¡ç®—ä¸€ä¸ªå­—ç¬¦ä¸²çš„å“ˆå¸Œå€¼ï¼ŒæŠŠæ¯ä¸ªå­—ç¬¦çœ‹ä½œæ¯ä¸ªè¿›åˆ¶ä½ä¸Šçš„ä¸€ä¸ªæ•°å­—ï¼Œè¿™ä¸ªä¸²è½¬æ¢ä¸ºä¸€ä¸ªåŸºäºè¿›åˆ¶Pï¼Œçš„æ•°ï¼Œæœ€åå¯¹Må–ä½™æ•°ï¼Œå°±å¾—åˆ°äº†è¿™ä¸ªå­—ç¬¦ä¸²çš„å“ˆå¸Œå€¼ã€‚

è¿›åˆ¶På¸¸ç”¨çš„å€¼æœ‰31ã€131ã€1313ã€13131ã€131313ã€‚ç”¨è¿™äº›æ•°å€¼èƒ½æœ‰æ•ˆé¿å…ç¢°æ’ã€‚

æ´›è°·P3370(set<stirng>)

å¦‚é¢˜ï¼Œç»™å®š Nä¸ªå­—ç¬¦ä¸²ï¼ˆç¬¬ iä¸ªå­—ç¬¦ä¸²é•¿åº¦ä¸º $M_i$ï¼Œå­—ç¬¦ä¸²å†…åŒ…å«æ•°å­—ã€å¤§å°å†™å­—æ¯ï¼Œè¯·æ±‚å‡º Nä¸ªå­—ç¬¦ä¸²ä¸­å…±æœ‰å¤šå°‘ä¸ªä¸åŒçš„å­—ç¬¦ä¸²ã€‚

```c++
#include <bits/stdc++.h>
using namespace std;
#define ull unsigned long long
ull a[10010];
char s[10010];
ull BKDRHash(char *s)
{
	ull P = 131,H = 0;
	int n = strlen(s);
	for(int i = 0;i < n;i++)
	{
		H = H * P + s[i] - 'a' + 1;
	}
	return H;
}
int main ()
{
	int n;
	cin>>n;
	for(int i  = 0;i < n;i++)
	{
		cin>>s;
		a[i] = BKDRHash(s);
	}
	int ans = 0;
	sort(a, a+n);
	for(int i = 0;i < n;i++)
	{
		if(a[i] != a[i+1])
			ans++;
	}
	cout<<ans;
}
```

å­—ç¬¦ä¸²çš„å„ç§æ“ä½œå¯¹åº”çš„å“ˆå¸Œè®¡ç®—éƒ½èƒ½æŒ‰Pè¿›åˆ¶æ•°çš„è¿ç®—è§„åˆ™è¿›è¡Œã€‚è®¾å­—ç¬¦ä¸²Sçš„å“ˆå¸Œå€¼ä¸º$H(S)$ï¼Œé•¿åº¦ä¸º$len(S)$ã€‚ä»¥ä¸¤ä¸ªå­—ç¬¦ä¸²çš„ç»„åˆä¸ºä¾‹ï¼Œä¸¤ä¸ªå­—ç¬¦ä¸²ç»„åˆ$S_1+S_2$çš„å“ˆå¸Œå€¼ä¸º$H(S)*P^{len(S_2)}+H(S_2)$ã€‚å…¶ä¸­ä¹˜ä»¥$P^{len(S_2)}$ç›¸å½“äºå·¦ç§»äº†$len(S_2)$ä½ã€‚

ä¾‹å¦‚ï¼Œ$S_1=$"abc",$S_2=$"xy"ï¼Œ$S_1+S_2=$"abcxy"çš„å“ˆå¸Œå€¼ç­‰äº$H(abc)*P^2+H(xy)$ã€‚

åˆ©ç”¨è¿›åˆ¶å“ˆå¸Œå¯ä»¥æŒ‰è¿›åˆ¶åšç®—æ•°è¿ç®—çš„ç‰¹æŠ˜æ¥å¿«é€Ÿè®¡ç®—Sçš„å‰ç¼€ã€‚ä¾‹å¦‚,$S = $"abcdefg"ï¼Œå®ƒçš„å‰ç¼€æœ‰$\{a,ab,abc,abcd,â€¦â€¦\}$ã€‚

é¦–å…ˆè®¡ç®—å‰ç¼€aï¼Œå¾—åˆ°$H(a)$ï¼Œç„¶åå‰ç¼€abï¼Œ$H(ab) = H(a)*P+H(b)$ï¼Œå‰ç¼€abcï¼Œ$H(abc) = H(ab) * P+H(c)$ã€‚

æŸ¥è¯¢ä»»æ„å­ä¸²å“ˆå¸Œå€¼ï¼Œ$H(de) = H(abcde)-H(abc) * P^2$ã€‚

æ±‚åŒºé—´[L,R]çš„å“ˆå¸Œå€¼

```c++
ull get_hash(ull L,ull R)
{
	return H[R] - H[L - 1] * P[R-L+1];
}
```

## Manacher

å¯¹äºå­—ç¬¦ä¸²$abababacababacd$å–ä¸­å¿ƒç‚¹cï¼Œå¾—åˆ°å…¶æœ€å¤§å›æ–‡ä¸²ä¸º$$

å¯¹äºå­—ç¬¦ä¸²$abababacababacd$å–ä¸­å¿ƒç‚¹cï¼Œå¾—åˆ°å…¶æœ€å¤§å›æ–‡ä¸²ä¸º$$

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 11000002;
int n,P[N<<1];//ä»¥S[i]ä¸ºä¸­å¿ƒçš„ä¼šé—®ç­çº§
char a[N],S[N<<1];
void change()
{
	n = strlen(a);
	int k = 0;
	S[k++] = '$';
	S[k++] = '#';
	for(int i = 0;i < n;i++)
	{
		S[k++] = a[i];
		S[k++] = '#';
	}
	S[k++] = '&';
	n = k;
}
void manacher()
{
	int R =0,C;//Rä¸ºå¯¹åº”å›æ–‡ä¸²çš„æœ€å¤§å³ç«¯ç‚¹
	for(int i = 1;i < n;i++)
	{
		if(i < R)
			P[i] = min(P[(C<<1) - i],P[C] + C - i);//åˆå¹¶å¤„ç†ä¸¤ç§æƒ…å†µ
		else
			P[i] = 1;
		while(S[i + P[i]] == S[i - P[i]])//ä¸­å¿ƒæ‰©å±•
			P[i]++;
		if(P[i] + i >R)
		{
			R = P[i] + i;//æ›´è¡Œæœ€å¤§R
			C = i;
		}
	}
}
int main ()
{
	cin>>a;
	change();
	manacher();
	int ans = 1;
	for(int i = 0;i < n;i++)
	{
		ans = max(ans,P[i]);
	}
	cout<<ans - 1;
	return 0;
}
```

## KMP

```cpp
/**
 * è·å–nextæ•°ç»„
 * @par t æ¨¡å¼ä¸²
 * @return nextæ•°ç»„
 */
std::vector<int> get_next(const std::string& t) {
    int m = t.size();
    std::vector<int> next(m, 0);
    int j = 0;  // jä¸ºæ¨¡å¼ä¸²ä¸­å·²åŒ¹é…çš„å‰ç¼€é•¿åº¦
    for (int i = 1; i < m; ++i) {
        while (j > 0 && t[i] != t[j]) {
            j = next[j - 1];
        }
        if (t[i] == t[j]) {
            ++j;
        }
        next[i] = j;
    }
    return next;
}

/**
 * tmpç®—æ³•åŒ¹é…æ¨¡å¼ä¸²
 * @par s æ–‡æœ¬ä¸²
 * @par t æ¨¡å¼ä¸²
 * @return tåœ¨sä¸­å‡ºç°çš„æ‰€æœ‰ä½ç½®ï¼ˆèµ·å§‹ç´¢å¼•ï¼‰ï¼Œè‹¥ä¸å­˜åœ¨ï¼Œåˆ™è¿”å›ç©ºåˆ—è¡¨
 */
std::vector<int> kmp(const std::string& s, const std::string& t) {
    std::vector<int> res;
    std::vector<int> next = get_next(t);
    int n = s.size(), m = t.size();
    int j = 0;  // jä¸ºæ¨¡å¼ä¸²ä¸­å·²åŒ¹é…çš„å‰ç¼€é•¿åº¦
    for (int i = 0; i < n; ++i) {
        while (j > 0 && s[i] != t[j]) {
            j = next[j - 1];
        }
        if (s[i] == t[j]) {
            ++j;
        }
        // æ¨¡å¼ä¸²åŒ¹é…å®Œ
        if (j == m) {
            res.push_back(i - m + 1);
            j = next[j - 1];
        }
    }
    return res;
}
```

## å­—å…¸æ ‘

```cpp
const int N = 8e5 + 3;

struct node {
    int cnt; // è¿™ä¸ªå‰ç¼€å‡ºç°çš„æ¬¡æ•°
    int son[26]; // 26ä¸ªå­—æ¯ï¼Œ26ä¸ªå„¿å­
    bool repeat; // è¿™ä¸ªå‰ç¼€æ˜¯å¦é‡å¤
    node() {
        cnt = 0;
        memset(son, false, sizeof son);
        repeat = false;
    }
} trie[N];

int num = 0;

/**
 * æ’å…¥å­—ç¬¦ä¸²
 * @par str å¸¦æ’å…¥çš„å­—ç¬¦ä¸²
 */
void insert(char* s) {
    int v, len = strlen(s);
    int u = 0;
    for (int i = 0; i < len; i++) {
        v = s[i] - 'a';
        if (!trie[u].son[v]) {
            trie[u].son[v] = ++num;
        }
        u = trie[u].son[v];
    }
    trie[u].repeat = 1;
}

/**
 * æŸ¥è¯¢å­—ç¬¦ä¸²
 * @par å¾…æŸ¥è¯¢çš„å­—ç¬¦ä¸²
 * @return 1=å­˜åœ¨ 2=é‡å¤ 3=ä¸å­˜åœ¨
 */
int find(char* s) {
    int v, u = 0, len = strlen(s);
    for (int i = 0; i < len; i++) {
        v = s[i] - 'a';
        if (!trie[u].son[v]) {
            return 3;
        }
        u = trie[u].son[v];
    }
    if (!trie[u].repeat) {
        return 3;
    }
    if (!trie[u].cnt) {
        trie[u].cnt++;
        return 1;
    }
    return 2;
}
```

## åç¼€æ•°ç»„

æ±‚è§£å•æ¨¡åŒ¹é…é—®é¢˜

#### å€å¢æ³•è®¡ç®—åç¼€æ•°ç»„

```cpp
const int N = 2e5 + 5; // å­—ç¬¦ä¸²çš„é•¿åº¦

int sa[N], rk[N], tmp[N + 1];
int k, n;

/**
 * ç»„åˆæ•°æœ‰ä¸¤éƒ¨åˆ†
 * é«˜ä½æ˜¯rk[i]ï¼Œä½ä½æ˜¯rk[i + k]
 */
auto comp_sa = [&](int i, int j) -> bool {
    if(rk[i] != rk[j]) {
        return rk[i] < rk[j];
    } else {
        int ri = i + k <= n ? rk[i + k] : -1;
        int rj = j + k <= n ? rk[j + k] : -1;
        return ri < rj;
    }
};

/**
 * è®¡ç®—sçš„åç¼€æ•°ç»„
 * O(n log n)
 * @par s æ–‡æœ¬ä¸²
 * @par sa åç¼€æ•°ç»„ï¼Œéœ€è¦å¼€è¶³å¤Ÿçš„æ ˆç©ºé—´
 */
void calc_sa(const std::string& s, int* sa) {
    n = s.length();
    for(int i = 0; i <= n; ++i) {
        rk[i] = s[i];
        sa[i] = i;
    }
    for(k = 1; k <= n; k <<= 1) {
        std::sort(sa, sa + n, comp_sa);
        tmp[sa[0]] = 0;
        for(int i = 0; i < n; ++i) {
            tmp[sa[i + 1]] = tmp[sa[i]] + (comp_sa(sa[i], sa[i + 1]) ? 1 : 0);
        }
        for(int i = 0; i < n; ++i) {
            rk[i] = tmp[i];
        }
    }
}
```

#### è®¡æ•°æ’åºè®¡ç®—åç¼€æ•°ç»„

```cpp

```

#### å­—ç¬¦ä¸²åŒ¹é…

```cpp
/**
 * åœ¨sä¸­æŸ¥æ‰¾t
 * æ—¶é—´å¤æ‚åº¦ O(m log n)
 * @par s æ–‡æœ¬ä¸²
 * @par t æ¨¡å¼ä¸²
 * @par sa åç¼€æ•°ç»„
 * @return è¿”å›tåœ¨sä¸­çš„ä½ç½® 
 */
int find(const std::string& s, const std::string& t, int* sa) {
    int i = 0, j = s.length();
    while(j - i > 1) {
        int k = i + ((j - i) >> 1);
        if(s.compare(sa[k], t.length(), t) < 0) {
            i = k;
        } else {
            j = k;
        }
    }

    if(s.compare(sa[j], t.length(), t) == 0) {
        return sa[j];
    }
    if(s.compare(sa[i], t.length(), t) == 0) {
        return sa[i];
    }
    return -1; // æ²¡æ‰¾åˆ°
}
```



# å›¾è®º // TODO é‡å†™

## å›¾è®ºåŸºæœ¬ç®—æ³•

### é“¾å¼å‰å‘æ˜Ÿå»ºå›¾

```cpp
const int N = 1e5 + 3;

struct Edge {
    int to, next, weight;
} edge[N << 1];

int head[N], cnt;

/**
 * åˆå§‹åŒ–å›¾
 */
void init() {
    for(auto& h : head) {
        h = -1;
    }
    for(auto& e : edge) {
        e.next = -1;
    }
    cnt = 0;
}

/**
 * æ·»åŠ è¾¹
 * @par from èµ·ç‚¹
 * @par to ç»ˆç‚¹
 * @par weight è¾¹æƒ
 */
void add_edge(int from, int to, int weight) {
    edge[cnt].to = to;
    edge[cnt].weight = weight;
    edge[cnt].next = head[from];
    head[from] = cnt++;
}

/**
 * éå†curçš„é‚»æ¥ç»“ç‚¹
 * @par cur å½“å‰èŠ‚ç‚¹
 * @par func å¯¹é‚»æ¥ç»“ç‚¹çš„æ“ä½œé€»è¾‘ï¼Œå‚æ•°ä¸ºé‚»æ¥èŠ‚ç‚¹çš„ç´¢å¼•
 * @brief å¯ä»¥ä½¿ç”¨ä»¥ä¸‹ä»£ç éå†é‚»æ¥èŠ‚ç‚¹
 *      for_each(cur, [&](int i) {
 *          int neighbor = edge[i].to;
 *          int weight = edge[i].weight;
 *          ...
 *      })
 */
void for_each(int cur, const std::function<void(int)>& func) {
    for(int i = head[cur]; ~i; i = edge[i].next) {
        func(i);
    }
}
```

### dfs

```cpp
bool vis[N];

static void init_vis() {
    memset(vis, 0, sizeof vis);
}

static void dfs_algorithm(int u, const std::function<void(int)>& func) {
    func(u);
    vis[u] = true;
    for_each(u, [&](int i) {
        int to = edge[i].to;
        if (!vis[to]) {
            dfs_algorithm(to, func);
        }
    });
}

void dfs(int u, const std::function<void(int)>& func) {
    init_vis();
    dfs_algorithm(u, func);
}
```

### bfs

```cpp
void bfs(int u, const std::function<void(int)>& func) {
    init_vis();
    std::queue<int> q;
    vis[u] = true;
    q.push(u);
    while (!q.empty()) {
        int k = q.front();
        q.pop();
        func(k);
        for_each(k, [&](int i) {
            int to = edge[i].to;
            if (!vis[to]) {
                q.push(to);
                vis[to] = true;
            }
        });
    }
}
```

### SPFA

```cpp
/**
 * SPFAç®—æ³•æ±‚æœ€çŸ­è·¯å¾„
 * @par s èµ·ç‚¹
 * @par t ç»ˆç‚¹
 * @return æœ€çŸ­è·¯å¾„æƒé‡
 */
int SPFA(int s, int t) {
    int dist[N];
    std::queue<int> q;

    init_vis();
    std::fill(dist, dist + N, INF);

    q.push(s);
    vis[s] = true;
    dist[s] = 0;

    while (!q.empty()) {
        int cur = q.front();
        q.pop();
        vis[cur] = false;

        for_each(cur, [&](int i) {
            int to = edge[i].to;
            int w = edge[i].w;
            if (dist[to] > dist[cur] + w) {
                dist[to] = dist[cur] + w;
                if (!vis[to]) {
                    q.push(to);
                    vis[to] = true;
                }
            }
        });
    }
    return dist[t];
}
```

### SPFA SLFä¼˜åŒ–

```cpp
int SPFA_SLF(int s, int t) {
    int dist[N];
    std::deque<int> dq;

    init_vis();
    std::fill(dist, dist + N, INF);

    dq.push_back(s);
    vis[s] = true;
    dist[s] = 0;

    while (!dq.empty()) {
        int cur = dq.front();
        dq.pop_front();
        vis[cur] = false;

        for_each(cur, [&](int i) {
            int to = edge[i].to;
            int w = edge[i].w;
            if (dist[to] > dist[cur] + w) {
                dist[to] = dist[cur] + w;
                if (!vis[to]) {
                    vis[to] = true;
                    if (dq.size() && dist[to] >= dist[dq.front()]) {
                        dq.push_back(to);
                    } else {
                        dq.push_front(to);
                    }
                }
            }
        });
    }

    return dist[t];
}
```

## åŸºç¯æ ‘

åŸºç¯æ ‘ä¸­å¯»æ‰¾æœ€é•¿é“¾çŠ¶é‡‡ç”¨dfs

ä¾‹å¦‚2->3->4->3

æ­¤æ—¶ä¸€æ¡è·¯å¾„2343ä¸ºæœ€é•¿è·¯å¾„ï¼Œä¹‹ådir[3]dir[4]ä¸º1ä¸ä¼šæœç´¢ï¼Œå› ä¸ºä»–ä»¬ä¸€å®šæ²¡æœ‰dir[2]æœ€é•¿ã€‚

é‚£ä¹ˆå¦‚æœä»dir[3]å¼€å§‹ï¼Œdir[4]ä¹Ÿä¸ä¼šæœç´¢äº†ã€‚å› æ­¤2æ˜¯è¿›å…¥é“¾çš„æ–¹å‘ï¼Œä¸€æ—¦æœ‰1æ¡ç»„æˆçš„ç¯ï¼Œç¯å†…çš„æ•°éƒ½ä¸ç”¨æœç´¢äº†ã€‚

```cpp
int a[N];
int dir[N],s[N];
void dfs(int x,int sum)
{
	if(s[x] = 1)//è·¯å¾„é‡å¤
	{
		ans = max(ans, sum);
		return;
	}
	dir[x] = 1;//å‰ªæï¼Œæ ‡è®°æ­¤ç‚¹å·²ç»æœç´¢è¿‡äº†
	s[x] = 1;//æ ‡è®°æ­¤ç‚¹åœ¨çº¿è·¯ä¸Š
	dfs(s[x],sum+1)
	s[x] = 0;//æœç´¢å®Œæ¯•è·¯å¾„æ ‡è®°è¿˜åŸ
}
int main()
{
	int n,i;
	cin<<n;
	for(i = 1;i<= n;i++)
	{
		int t;
		cin>>t;
		a[i] = t;
	}
	for(i = 1;i <= n;i++)
	{
		while(!dir[x])
		{
			dfs(i,0)//ä»ç¬¬ä¸€ä¸ªç‚¹å¼€å§‹æœç´¢
		}
	}
}
```

## æ ‘é“¾å‰–åˆ†æ±‚LCA

```cpp
class HLD {
public:
    HLD(int n) {
        this->n = n;
        matrix.resize(n + 1);
        size.resize(n + 1);
        depth.resize(n + 1);
        top.resize(n + 1);
        son.resize(n + 1);
        parent.resize(n + 1);
    }

    /**
     * æ·»åŠ åŒå‘è¾¹
     * @par from èµ·ç‚¹
     * @par to ç»ˆç‚¹
     */
    void add_edge(int from, int to) {
        matrix[from].push_back(to);
        matrix[to].push_back(from);
    }

    /**
     * éå†curçš„é‚»æ¥ç»“ç‚¹
     * @par cur å½“å‰èŠ‚ç‚¹
     * @par func å¯¹é‚»æ¥ç»“ç‚¹æ‰§è¡Œçš„é€»è¾‘
     * 
     * func
     * @par é‚»æ¥ç»“ç‚¹
     */
    void for_each(int cur, const std::function<void(int)>& func) {
        for(auto& n : matrix[cur]) {
            func(n);
        }
    }

    /**
     * åˆå§‹åŒ–
     * O(n)
     * @par root æ ¹èŠ‚ç‚¹
     */
    void init(int root = 1) {
        dfs1(root);
        dfs2(root, root);
    }

    /**
     * æ±‚è§£lca
     * O(log n)
     * @par x èŠ‚ç‚¹x
     * @par y èŠ‚ç‚¹y
     * @return è¿”å›èŠ‚ç‚¹xå’ŒèŠ‚ç‚¹yçš„LCAèŠ‚ç‚¹
     */
    int lca(int x, int y) {
        while(top[x] != top[y]) {
            if(depth[top[x]] > depth[top[y]]) {
                x = parent[top[x]];
            } else {
                y = parent[top[y]];
            }
        }
        return depth[x] < depth[y] ? x : y;
    }

    /**
     * æŸ¥è¯¢ä¸¤ç‚¹é—´çš„è·ç¦»
     * @par x èŠ‚ç‚¹x
     * @par y èŠ‚ç‚¹y
     * @return ä¸¤ç‚¹é—´çš„è·ç¦»
     */
    int distance(int x, int y) {
        return depth[x] + depth[y] - (depth[lca(x, y)] << 1);
    }

private:
    int n; // èŠ‚ç‚¹ä¸ªæ•°
    std::vector<std::vector<int>> matrix; // é‚»æ¥çŸ©é˜µ
    std::vector<int> size; // size[i] = jï¼šè¡¨ç¤ºièŠ‚ç‚¹çš„å­æ ‘å¤§å°ä¸ºj
    std::vector<int> depth; // depth[i] = jï¼šè¡¨ç¤ºièŠ‚ç‚¹çš„æ·±åº¦ä¸ºj
    std::vector<int> top; // top[i] = jï¼šè¡¨ç¤ºièŠ‚ç‚¹æ‰€åœ¨çš„é‡é“¾å¤´éƒ¨ä¸ºj
    std::vector<int> son; // son[i] = jï¼šè¡¨ç¤ºièŠ‚ç‚¹çš„é‡å„¿å­ä¸ºj
    std::vector<int> parent; // father[i] = jï¼šè¡¨ç¤ºièŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹ä¸ºj

    /**
     * ç¬¬ä¸€æ¬¡dfs
     * @par cur å½“å‰èŠ‚ç‚¹
     */
    void dfs1(int cur) {
        size[cur] = 1;
        depth[cur] = depth[parent[cur]] + 1;
        for_each(cur, [&](int neighbor) {
            if(neighbor == parent[cur]) {
                return; // continue
            }

            parent[neighbor] = cur;
            dfs1(neighbor);
            // æ›´æ–°å½“å‰èŠ‚ç‚¹çš„å­æ ‘å¤§å°
            size[cur] += size[neighbor];
            // å¯»æ‰¾é‡å„¿å­
            if(size[neighbor] > size[son[cur]]) {
                son[cur] = neighbor;
            }
        });
    }

    /**
     * ç¬¬äºŒæ¬¡dfs
     * @par cur å½“å‰èŠ‚ç‚¹
     * @par up å½“å‰èŠ‚ç‚¹çš„é‡é“¾å¤´éƒ¨
     */
    void dfs2(int cur, int up) {
        top[cur] = up;
        if(son[cur]) {
            dfs2(son[cur], up);
        }
        for_each(cur, [&](int neighbor) {
            if(neighbor == parent[cur] || neighbor == son[cur]) {
                return; // continue
            }
            dfs2(neighbor, neighbor);
        });
    }
};
```



# æ•°è®º

## æ¨¡è¿ç®—

å–æ¨¡è¿ç®—ä¸ºæ±‚aé™¤ä»¥mçš„ä½™æ•°ï¼Œè®°ä¸º$a\mod\ m = a \% m$ã€‚

CåŠJavaå–æ¨¡è¿ç®—è§„åˆ™ï¼š$5 \% 3 = 2ï¼Œ(-5)\%(-3)= -2ï¼Œ5\%(-3) = 2ï¼Œ(-5)\% 3 = -2$

å…ˆæŒ‰æ­£æ•´æ•°å–ä½™ï¼Œç„¶ååŠ ä¸Šç¬¦å·ï¼Œç¬¦å·ä¸è¢«é™¤æ•°ä¿æŒä¸€è‡´ã€‚

æ€§è´¨ï¼š

1. $( a + b ) \mod m = ( (a \mod m) + (b \mod m) ) \mod m$å¦‚æœæ²¡æœ‰é™åˆ¶abæ­£è´Ÿï¼ŒCä»£ç ä¸­å·¦å³å¯èƒ½ç¬¦å·ç›¸åã€å¤§å°ç›¸å·®mã€‚

2. $( a - b ) \mod m = ( (a \mod m) - (b \mod m) ) \mod m$å¦‚æœæ²¡æœ‰é™åˆ¶abæ­£è´Ÿï¼ŒCä»£ç ä¸­å·¦å³å¯èƒ½ç¬¦å·ç›¸åã€å¤§å°ç›¸å·®mã€‚

3. $( a * b )\mod m = ( (a \mod m) * (b \mod m) ) \mod m$ã€‚

4. å¯¹äºé™¤æ³•æ˜¯é”™è¯¯çš„ã€‚

å¯¹äºä¹˜æ³•çš„å¤§æ•°å–æ¨¡ï¼Œç›´æ¥ç”¨a*bä¼šæº¢å‡ºï¼Œ $(a \mod m) * (b \mod m)$ä¹Ÿå¯èƒ½æº¢å‡ºã€‚æ­¤æ—¶éœ€è¦è¿™æ ·é¿å…ã€‚

$a * b$æ”¹æˆ$(a * 2 * 2 * 2 * 2 * 2) * (b\div2\div2\div2\div2\div2)$ã€‚å¦‚æœbæ˜¯å¥‡æ•°å˜æˆ$(a * 2) * (b\div 2 + 1) = (a * 2) * (b\div 2) + (a * 2)$

å¦‚æœmæ¯”aå¤§ï¼Œmulå‡½æ•°ä»ä¼šå‡ºé”™ã€‚

```c++
long long mul (long long a,long long b, long long m)
{
	a = a % m;
	b = b % m;
	long long res = 0;
	while(b > 0)
	{
		if(b & 1)//åˆ¤æ–­å¥‡å¶
			res = (res + a) % m;
		a = (a + a) % m;
		b >>=1;
	}
	return res;
}
int main()
{
	long long a;
	long long b;
	long long m;
	cout<<mul(a, b, m);
}
```

## å¿«é€Ÿå¹‚

$a^{11} = a^8+a^2+a^1; 11 ={011_2}=2^3+2^1+2^0 = 8+ 2+ 1 $

```c++
long long fastpow(long long a,long long b,long long mod)
{
    long long ans = 1;
    a = a % mod;
    while(b)
    {
        if(b & 1)
        	ans = ans * a % mod;//è¦ä¹˜
   		a = a * a % mod;//é€’æ¨2 4 8 16
    	b = b >> 1;//è¿›ä½
    }
    return ans;
}
```

## çŸ©é˜µ

çŸ©é˜µä¹˜æ³•

$A = m * n , B = n * u,C =AB= m*u$

```c++
for(int i = 1;i <= m;i++)
    for(int j = 1;j <= u;j++)
        for(int k = 1;k <= n;k++)
            c[i][j] +=a[i][k] * b[k][j];
```

çŸ©é˜µå¿«é€Ÿå¹‚

```c++
struct matrix
{
	int m[N][N];
};
matrix operator * (const matrix &a,const matrix & b)//é‡è½½*ä¸ºçŸ©é˜µç›¸ä¹˜
{
	matrix c;
	memset(c.m, 0, sizeof(c.m));
	for(int i = 0;i < N;i++)
		for(int j = 0;j < N;j++)
			for(int k = 0;k < N;k++)
				//c.m[i][j] += a.m[i][k] * b.m[k][j];
				c.m[i][j] = (c.m[i][j] + a.m[i][k] * b.m[k][j]) % mod;
	return c;
}
matrix pow_matrix(matrix a,int n)
{
	matrix ans;
	memset(ans.m, 0, sizeof(ans.m));//å•ä½çŸ©é˜µ
	for(int i = 0;i < N;i++)
	{
		ans.m[i][i] = 1;
	}
	while(n)
	{
		if(n&1)
			ans = ans * a;
		a = a * a;
		n >>= 1;
	}
	return ans;
}
```

## GCDä¸LCM

### GCD

$gcd(a,b) = gcd(|a|,|b|)$ã€‚å› ä¸º$-a$çš„å› å­ä¸$a$ç›¸åŒ,æ‰€ä»¥$gcd(a,b) = gcd(|a|,|b|)$

äº’ç´ :$gcd(a,b) = 1$;

GCDæ€§è´¨

1.$gcd(a,b) = gcd(a, a+b) = gcd(a,k*a+b)$

2.$gcd(ka,kb) = k * gcd(a,b)$

3.å®šä¹‰å¤šä¸ªæ•´æ•°çš„GCDï¼š$gcd(a,b,c) = gcd[gcd(a,b),c]$

4.è‹¥$gcd(a,b) = d$ï¼Œåˆ™$gcd(a/d,b/d) = 1$,å³$a/d$ä¸$b/d$äº’ç´ 

5.$gcd(a+cd,b) = gcd(a,b)$

#### æ¬§å‡ é‡Œå¾—ç®—æ³•

$gcd(a,b) = gcd(b,a \% b)$

```c++
int mygcd(int a, int b)
{
	return b ? gcd(b,a%b): a;
}
```

æ­¤ç®—æ³•è¦åšå–æ¨¡ï¼Œé«˜ç²¾åº¦é™¤æ³•å–æ¨¡è€—æ—¶ï¼Œå¯ä»¥é‡‡ç”¨ä»¥ä¸‹ç®—æ³•ã€‚

#### æ›´ç›¸å‡æŸæœ¯

$gcd(a,b) = gcd(b,b -a)=gcd(a,a-b)$

```c++
int mygcd(int a, int b)
{
    while(a != b)
    {
        if(a > n)
            a = a - b;
        else
            b = b - a;
    }
    return a;
}
```

#### Steinç®—æ³•

(1)aå’Œbéƒ½æ˜¯å¶æ•°ã€‚$gcd(a,b) = 2gcd(a/2,b/2)$

(2)aå¥‡bå¶æ•°ï¼ˆaå¶bå¥‡ï¼‰ã€‚è‹¥kä¸yäº’ä¸ºè´¨æ•°ï¼Œæœ‰$gcd(kx,y) = gcd(x,b)$ã€‚å½“k  = 2ï¼Œbä¸ºå¥‡æ•°æ—¶ï¼Œæœ‰$gcd(a,b) = gcd(a/2,b)$ã€‚

(3)aå’Œbéƒ½æ˜¯å¥‡æ•°ã€‚$gcd(a,b) = gcd((a+b)/2,(a-b)/2)$

```c++
int stein(int a,int b)
{
	if(a < b)
	{
		a^=b;
		b^=a;
		a^=b;
	}
	if(b==0)
		return a;
	if( (!(a&1)) && (!(b&1)) )
		return stein(a>>1,b>>1) << 1;
	else if( (a&1) && (!(b&1)) )
		return stein(a,b>>1);
	else if(!(a&1)) && (b&1) )
		return stein(a>>1,b);
	else
		return stein(a-b,b);
}
```

### LCM

$gcd(a,b)lcm(a,b)=ab$,å³$lcm(a,b) = ab/gcd(a,b) = a/gcd(a,b)b$

å…ˆé™¤åä¹˜

```c++
int lcm(int a,int b)
{
	return a / gcd(a,b) * b;
}
```



#### è£´èœ€å®šç†

å¦‚æœaä¸bå‡ä¸ºæ•´æ•°ï¼Œåˆ™æœ‰æ•´æ•°xå’Œyä½¿$ax+by=gcd(a,b)$ã€‚

##### æ´›è°·P4549 

```c++
#include <iostream>
using namespace std;
int a[100003];
long long gcd(int a,int b)
{
    return b ? gcd(b,a%b):a;
}
int main ()
{
    int n;
    int i;
    cin>>n;
    for(i = 0;i < n;i++)
    {
        cin>>a[i];
    }
    long long sum = 0;
    sum = gcd(abs(a[0]),abs(a[1]));
    for(i = 1;i < n;i++)
    {
        sum = gcd(abs(a[i]),sum);
    }
    cout<<sum;
}
```



## çº¿æ€§ä¸¢ç•ªå›¾æ–¹ç¨‹

æ–¹ç¨‹$ax + by = c$æˆä¸ºäºŒå…ƒæ€§ä¸¢ç•ªå›¾æ–¹ç¨‹ï¼Œå¦‚æœç›´çº¿ä¸Šæœ‰æ•´æ•°åæ ‡ç‚¹ï¼Œå°±æœ‰è§£ï¼Œæ²¡æœ‰åˆ™æ— è§£ï¼Œå¦‚æœå­˜åœ¨ä¸€ä¸ªè§£å°±æœ‰æ— æ•°ä¸ªè§£ã€‚

è®¾aï¼Œbä¸ºæ•´æ•°ä¸”$gcd(aï¼Œb) = d$ã€‚å¦‚æœdä¸èƒ½æ•´é™¤cï¼Œé‚£ä¹ˆæ–¹ç¨‹$ax + by = c$æ²¡æœ‰æ•´æ•°ï¼Œå¦åˆ™å­˜åœ¨æ— ç©·å¤šä¸ªè§£ã€‚å¦‚æœï¼ˆ${x_0}$ï¼Œ${y_0}$ï¼‰æ˜¯æ–¹ç¨‹çš„ä¸€ä¸ªç‰¹è§£ï¼Œé‚£ä¹ˆæ‰€æœ‰è§£å¯ä»¥è¡¨ç¤ºä¸º$x = {x_0}+\frac{b}{d}*n$ï¼Œ$y = {y_0}-\frac{a}{d}*n$,nä¸ºä»»æ„æ•´æ•°ã€‚

### æ‰©å±•æ¬§å‡ é‡Œå¾—æ±‚ç‰¹è§£

è¿­ä»£æ—¶$gcd(a,0) = a$   $ax + 0y = gcd(a,0) = a$æ­¤æ—¶æœ‰ç‰¹è§£$x = 1,y = 0$ã€‚

$gcd(a,b) = gcd(b,a\%b)$ã€‚$ax + by = gcd(a,b)$ã€‚

$ax + by = bx'+a\%by' = bx'+[a-b(a/b)]y' = bx' + ay' - b(a/b)y' = ay'+b[x'-(a/b)y']$

$ \begin{cases}x = y' \\y = x'-(\frac{a}{b})y\end{cases} $

ä½¿ç”¨æ¬§å‡ é‡Œå¾—æ±‚$ax + by = gcd(a,b)$çš„ä¸€ä¸ªç‰¹è§£ä¹‹åï¼Œå¯ä»¥æ±‚$ax + by = c$çš„ä¸€ä¸ªé€šè§£ã€‚

è®°$d = gcd(a,b)$ï¼Œæ­¤æ—¶$gcd(a,b)$èƒ½æ•´é™¤$c$ã€‚æ¬§å‡ é‡Œå¾—æ±‚å‡ºçš„ç‰¹è§£ä¸º$(x_0,y_0)$ã€‚tyjk./

åœ¨$ax_0+by_0 = d$ä¸¤è¾¹åŒæ—¶ä¹˜ä»¥$c / d$ï¼Œå¾— $ax_0c/d+by_0c/d = c$ï¼Œæ­¤æ—¶å¯ä»¥å¾—åˆ°$ax + by = c$çš„ä¸€ä¸ªè§£ä¸º$(x_0',y_0')$ã€‚

å³$x_0=x_0c/d ï¼Œy_0 = y_0c/d$ã€‚æ•…é€šè§£ä¸º$x = x_0'+(b/d)nï¼Œy = y_0'-(a/d)n$ã€‚

æ³¨ï¼šæ¬§å‡ é‡Œå¾—æ±‚å‡ºçš„æ˜¯$ax + by = gcd(a,b)$çš„ç‰¹è§£ã€‚

```c++
long long extend_gcd(long long a, long long b, long long &x,long long &y)//è¿”å›gcd(a,b),æ”¹å˜ç‰¹è§£xï¼Œy
{
	if(b==0)
	{
		x = 1;
		y = 0;
		return 0;
	}
	long long d = extend_gcd(b, a%b, y,x);
	y = y - a / b * x;
	return d;
}
```

æ±‚æœ€å°è§£ã€‚

å·²çŸ¥é€šè§£ä¸º$x = x_0 + (b/d)n$è¦ä½¿$x$æœ€å°ï¼Œåˆ™éœ€è¦$x_0$ä¸æ–­çš„å‡$b/d$ã€‚é‚£ä¹ˆæ­¤è¿‡ç¨‹ç›¸å½“äºå–æ¨¡

å…¬å¼ä¸º$((x_0 \% (b/d)+b/d)\%(b/d))$ å¤šåŠ ä¸€æ¬¡å†å»æ¨¡é˜²æ­¢è´Ÿæ•°ã€‚

##### æ´›è°·P1516

```c++
#include <iostream>

using namespace std;
long long exgcd(long long a,long long b,long long &x,long long &y)
{
    if(b == 0)
    {
        x = 1;
        y = 0;
        return a;
    }
    long long d = exgcd(b,a%b,y,x);
    y -= a/b*x;
    return d;
}
int main () {
    long long x, y, m, n, l;
    cin >> x >> y >> m >> n>>l;
    long long  c = x - y;
    long long a = n - m;
    if (a < 0) {
        a = -a;
        c = -c;
    }
    long long d = exgcd(a, l, x, y);
    if (c % d != 0)
        cout << "Impossible";
    else
        cout << ((x*c/d ) % (l / d) + (l / d)) % (l / d);
}
```

### å¤šå…ƒçº¿æ€§ä¸¢ç•ªå›¾æ–¹ç¨‹

å¦‚æœ$a_1,a_2,a_3,â€¦â€¦,a_n$æ˜¯éé›¶æ•´æ•°ï¼Œé‚£ä¹ˆæ–¹ç¨‹$a_1x_1+a_2x_2+â€¦â€¦+a_nx_n = c$æœ‰æ•´æ•°è§£ï¼Œå½“ä¸”ä»…å½“$d = gcd(a_1,a_2,â€¦â€¦,a_n)$æ•´é™¤$c$ï¼Œå¦‚æœæ–¹ç¨‹å­˜åœ¨ä¸€ä¸ªè§£ï¼Œåˆ™æ–¹ç¨‹æœ‰æ— æ•°å¤šä¸ªè§£ã€‚

## åŒä½™ 

åŒä½™å®šä¹‰ï¼šè®¾mæ˜¯æ­£æ•´æ•°ï¼Œè‹¥aå’Œbæ˜¯æ•´æ•°ï¼Œä¸”$m \lvert (a - b)$ï¼Œåˆ™ç§°a å’Œ b æ¨¡åŒä½™ï¼Œä¹Ÿå°±æ˜¯è¯´ aé™¤ä»¥må¾—åˆ°çš„ä½™æ•°ï¼Œå’Œbé™¤ä»¥mçš„ä½™æ•°ç›¸åŒï¼›æˆ–è€…è¯´a - b é™¤ä»¥m ï¼Œä½™æ•°ä¸º0ï¼Œå› ä¸ºaå’Œbä¸­é—´éš”äº†nä¸ªmã€‚

åŒä½™è®°ä½œ$a \equiv b(\mod m)$,mä¸ºåŒä½™çš„æ¨¡ã€‚

ä¾‹å¦‚$7 \lvert(18 - 4)$ï¼Œæ‰€ä»¥ $18 \equiv 4(\mod 7)$ã€‚

åŒä½™çš„æ€§è´¨

è‹¥aå’Œbä¸ºæ•´æ•°ï¼Œmä¸ºæ­£æ•´æ•°ï¼Œåˆ™$a \equiv b(\mod m)$å½“ä¸”ä»…å½“$a \mod m = b \mod m$ã€‚

åŒä½™è½¬åŒ–ä¸ºç­‰å¼ã€‚è‹¥a å’Œ b æ˜¯æ•´æ•°ï¼Œ åˆ™ $a \equiv b(\mod m)$ å½“ä¸”ä»…å½“ å­˜åœ¨æ•´æ•°kï¼Œä½¿ $a = b  + km$ã€‚

è®¾mæ˜¯æ­£æ•´æ•°ï¼Œæ¨¡måŒä½™çš„æ€§è´¨

ï¼ˆ1ï¼‰è‡ªåæ€§ï¼š$a \equiv a(\mod m)$

ï¼ˆ2ï¼‰å¯¹ç§°æ€§ï¼š$a \equiv b(\mod m)åˆ™b \equiv a(\mod m)$

ï¼ˆ3ï¼‰ä¼ é€’æ€§ï¼š$a \equiv b(\mod m)ï¼Œb \equiv c(\mod m)ï¼Œåˆ™a \equiv c(\mod m)$

### ä¸€å…ƒçº¿æ€§åŒä½™æ–¹ç¨‹

è®¾xæ˜¯æœªçŸ¥æ•°ï¼Œç»™å®š$aã€bã€m$ï¼Œæ±‚æ•´æ•°xï¼Œæ»¡è¶³$ax\equiv b(\mod m) $ã€‚åˆ™æœ‰$ax + my = b$ï¼Œè¿™æ˜¯äºŒå…ƒçº¿æ€§ä¸¢ç•ªå›¾æ–¹ç¨‹ã€‚

æ‰€ä»¥ï¼Œæ±‚è§£ä¸€å…ƒçº¿æ€§åŒä½™æ–¹ç¨‹ç­‰ä»·äºæ±‚è§£äºŒå…ƒçº¿æ€§ä¸¢ç•ªå›¾æ–¹ç¨‹ã€‚

### é€†

ç»™å®šæ•´æ•°aï¼Œä¸”æ»¡è¶³$gcd(a,m) = 1$ï¼Œç§°$ax \equiv 1(\mod m)$çš„ä¸€ä¸ªè§£ä¸ºaæ¨¡mçš„é€†å…ƒï¼Œè®°$a^{-1}$ã€‚

ä¾‹å¦‚ï¼Œ$8x \equiv 1(\mod 31)$,æœ‰ä¸€ä¸ªè§£æ˜¯$x = 4$ï¼Œ4æ˜¯8æ¨¡31çš„é€†ã€‚æ‰€æœ‰è§£ï¼Œå¦‚36ã€66ç­‰ä¹Ÿæ˜¯8æ¨¡31çš„é€†ã€‚

ä¹Ÿå¯ä»¥åŒ–ä¸º$8x + 31y = 1$,$x = 4$æ˜¯8æ¨¡31çš„é€†ã€‚å¯ä»¥çœ‹å‡ºmæœ€å¥½æ˜¯å¤§äºaçš„ç´ æ•°ï¼Œæ‰èƒ½ä¿è¯$gcd(a,m) = 1$ã€‚

#### æ±‚é€†

##### æ‰©å±•æ¬§å‡ é‡Œå¾—æ±‚é€†

æ´›è°·P1082

```c++
//
// Created by ZA on 2024/8/29.
//
#include <iostream>
using namespace std;
long long excd(long long a,long long b,long long &x,long long &y)
{
    if(b == 0)
    {
         x = 1;
         y = 0;
        return a;
    }
    long long d = excd(b, a%b,y,x);
    y -= a/b*x;
    return d;
}
int main ()
{
    long long a,b;
    long long y,x;
    cin>>a>>b;
    long long d = excd(a,b,x,y);

    cout<<(x % b + b) %b;
}
```

##### è´¹é©¬å°å®šç†

è®¾næ˜¯ç´ æ•°ï¼Œaæ˜¯æ­£æ•´æ•°ä¸”ä¸näº’ç´ ï¼Œæœ‰$a^{n-1} \equiv 1(\mod n)$ã€‚

$a*a^{n-2} \equiv1(\mod n)$ï¼Œé‚£ä¹ˆ$a^{n-2} \mod n$å°±æ˜¯aæ¨¡nçš„é€†å…ƒã€‚

```c++
long long mod_inverse(long long a,long long mod)
{
	return fast_pow(a,mod - 2,mod);
}
```

2024 ICPC æ¹–åŒ—

ç»™å®šnä¸ªæ•´æ•°ï¼Œæ±‚å¹³å‡å€¼

æ±‚nçš„é€†ï¼Œé‡‡ç”¨è´¹é©¬æœ€å°å®šç†ï¼Œä½¿ç”¨å¿«é€Ÿå¹‚å‡½æ•°ã€‚

```c++
#include <bits/stdc++.h>

using namespace std;
long long m = 998244353;
long long fastpow(long long a,long long b,long long mod)
{
    long long ans = 1;
    a = a % mod;
    while(b)
    {
        if(b & 1)
        	ans = ans * a % mod;//??
   		a = a * a % mod;//??2 4 8 16
    	b = b >> 1;//??
    }
    return ans;
}
long long a[1000003];
int main ()
{
	int n;
	long long sum = 0;
	int i;
	cin>>n;
	for(i = 0;i < n;i++)
	{
		cin>>a[i];
		sum +=a[i];
		sum = sum%m;
	}
	cout<<sum*fastpow(n,m - 2,m)%m;
    return 0;    
}
```



##### é€’æ¨æ±‚é€†

å¦‚æœè¦æ±‚1~nå†…æ‰€æœ‰é€†ï¼Œå¯ä»¥ç”¨é€’æ¨æ³•ã€‚å¤æ‚åº¦ä¸º$\Theta(n)$ã€‚

æ´›è°·P3811

ç»™å®š n,p æ±‚ 1âˆ¼nä¸­æ‰€æœ‰æ•´æ•°åœ¨æ¨¡ pæ„ä¹‰ä¸‹çš„ä¹˜æ³•é€†å…ƒã€‚

é¦–å…ˆ$i = 1$çš„é€†æ˜¯1ã€‚

è®¾$p/i = k$ï¼Œä½™æ•°æ˜¯$r$ï¼Œå³$k*i + r \equiv0(\mod p)$ï¼Œåœ¨ç­‰å¼ä¸¤è¾¹ä¹˜$i^{-1}*r^{-1}ï¼Œ$å¾—åˆ°$k*r^{-1} + i^{-1} \equiv 0(\mod p)$

ç§»é¡¹å¾—$i^{-1} \equiv -k*r^{-1}(\mod p)$ï¼Œå³$i^{-1} \equiv -p/i*r^{-1}(\mod p)$ï¼Œ$i^{-1} \equiv (p-p/i)*r^{-1}(\mod p)$ã€‚

å³$inv[i] = (p-p/i) *inv[p \% i]\%p$ã€‚è¯¥å¼å­ä¸­$-p/i$ä¸ºè´Ÿæ•°æ‰€ä»¥è¦å¤šåŠ ä¸ªä¸€ä¸ªpï¼Œå¹¶ä¸”ç”±äºæ¯æ¬¡æ“ä½œå·²ç»mod päº†ï¼Œæ‰€ä»¥ä¸¤å¼ç›¸ç­‰ã€‚

```cpp
long long inv[N];
void inverse(long long n,long long p)
{
	inv[1] =  1;
	for(int i = 2;i <= N;i++)
	{
		inv[i] = (p - p / i) * inv[p % i] % p;
	}
}
```

#### ç”¨é€†è§£æ±‚åŒä½™æ–¹ç¨‹

å¦‚æœæœ‰$a$æ¨¡$m$çš„ä¸€ä¸ªé€†ï¼Œå¯ä»¥ç”¨æ¥æ±‚è§£å½¢å¦‚$ax\equiv b (\mod m)$çš„ä»»ä½•åŒä½™æ–¹ç¨‹ã€‚

è®°$a^{-1}$æ˜¯$a$çš„ä¸€ä¸ªé€†ï¼Œæœ‰$a^{-1}a \equiv 1(\mod m)$ã€‚åœ¨$ax \equiv b(\mod m)$çš„ä¸¤è¾¹åŒæ—¶ä¹˜ä»¥$a^{-1}$ï¼Œå¾—åˆ°$a^{-1}ax \equiv a^{-1}b(\mod m)$ï¼Œå³$x \equiv a^{-1}b(\mod m)$ã€‚

ä¾‹å¦‚ï¼Œä¸ºäº†æ±‚å‡º$8x \equiv 22(\mod 31)$çš„è§£ï¼Œå¯ä»¥ä¸¤è¾¹ä¹˜ä»¥4ï¼Œ4æ˜¯8æ¨¡31 çš„ä¸€ä¸ªé€†å…ƒï¼Œå¾—åˆ°$4*8x\equiv 4*22(\mod 31)$ï¼Œæ‰€ä»¥$x \equiv 88(\mod 31) \equiv 26(\mod  31)$ã€‚

è®¾pæ˜¯ç´ æ•°ï¼Œæ­£æ•´æ•°aæ˜¯å…¶è‡ªèº«æ¨¡pçš„é€†ï¼Œå½“ä¸”ä»…å½“$a \equiv 1(\mod p)$æˆ–$a \equiv -1(\mod p)$ã€‚

#### é€†ä¸é™¤æ³•å–æ¨¡

æ±‚$(a/b) \mod m$ï¼Œå³aé™¤ä»¥bï¼Œç„¶åå¯¹må–æ¨¡ã€‚è¿™é‡Œaå’Œbéƒ½æ˜¯å¾ˆå¤§çš„æ•°ï¼Œå¦‚$a = n!$,å®¹æ˜“æº¢å‡ºï¼Œå¯¼è‡´å–æ¨¡é”™è¯¯ã€‚ç”¨é€†å¯ä»¥é¿å…é™¤æ³•è®¡ç®—ï¼Œè®¾bçš„é€†å…ƒæ˜¯$b^{-1}$ï¼Œæœ‰$(a/b) \mod m =(ab^{-1})\mod m)((bb^{-1}) \mod m) = (a/b*bb^{-1}) \mod m = (bb^{-1}) \ mod m = (ab^{-1}) \mod m$ã€‚

é™¤æ³•çš„æ¨¡è¿ç®—è½¬æ¢ä¸ºä¹˜æ³•æ¨¡è¿ç®—ã€‚

$(a/b) \mod m = (ab^{-1}) \mod m=(a \mod m)(b^{-1} \mod m) \mod m$ã€‚

## åŒä½™æ–¹ç¨‹ç»„

è®¾$m_1ï¼Œm_2ï¼Œâ€¦â€¦ï¼Œm_r$æ˜¯ä¸¤ä¸¤äº’ç´ çš„æ­£æ•´æ•°ï¼Œåˆ™åŒä½™æ–¹ç¨‹ç»„$x \equiv a_1 (\mod m_1)ï¼Œ$$x \equiv a_2 (\mod m_2)ï¼Œ$$x \equiv a_3 (\mod m_3)$ã€‚

ä¾‹å¦‚ï¼Œæœ‰ä¸€ä¸ªæ•°xï¼Œè¢«3é™¤ä½™2ï¼Œè¢«5é™¤ä½™3ï¼Œè¢«7é™¤ä½™2ï¼Œåˆ—æˆåŒä½™æ–¹ç¨‹æ˜¯ï¼š$x \equiv 2 (\mod 3)ï¼Œ$$x \equiv 3 (\mod 5)ï¼Œ$$x \equiv 2 (\mod 7)$ã€‚

æ±‚è§£ç»“æœä¸º$x = 32 + 3*5*7$ã€‚

#### ä¸­å›½å‰©ä½™å®šç†

è®¾$m_1ï¼Œm_2,â€¦â€¦ï¼Œm_r$æ˜¯ä¸¤ä¸¤äº’ç´ çš„æ­£æ•´æ•°ï¼Œåˆ™åŒä½™æ–¹ç¨‹ç»„æœ‰æ•´æ•°è§£ï¼Œå¹¶ä¸”æ¨¡$M=m_1*m_2â€¦â€¦*m_r$å”¯ä¸€ï¼Œè§£ä¸º

$x \equiv (a_1M_1{M_1}^{-1}+a_2M_2{M_2}^{-1}+â€¦â€¦+a_rM_r{M_r}^{-1})(\mod M)$å…¶ä¸­ï¼Œ$M_i = M/m_i ; {M_i}^{-1}$ä¸º$M_i$æ¨¡$m_i$çš„é€†å…ƒã€‚

ä¾‹å¦‚$x \equiv 2 (\mod 3)ï¼Œ$$x \equiv 3 (\mod 5)ï¼Œ$$x \equiv 2 (\mod 7)$      $M = 3*5*7=105$ã€‚

$M_1 = 105/3=35$ï¼Œ$M_2 = 105/5=21$ï¼Œ$M_3=105/7=15$ã€‚æ±‚é€†å¾—ï¼š${M_1}^{-1}=2,{M_2}^{-1}=1,{M_3}^{-1}=1$ã€‚

æœ€åè®¡ç®—$x \equiv 2*35*2+3*21*1+2*15*1 \equiv 233 \equiv 23(\mod 105)$ã€‚

#### è¿­ä»£æ³•

ä¸­å›½å‰©ä½™å®šç†çš„é™åˆ¶æ¡ä»¶ä¸ºä¸¤ä¸¤äº’ç´ ã€‚åœ¨ä¸äº’ç´ ä¸­é‡‡ç”¨è¿­ä»£æ³•ã€‚è‹¥xå’Œaæ˜¯æ•´æ•°ï¼Œåˆ™$x \equiv a(\mod m)$å½“ä¸”ä»…å½“å­˜åœ¨æ•´æ•°ï¼Œä½¿$x = a+km$

ä¾‹å¦‚ã€‚$x \equiv 2 (\mod 3)ï¼Œ$$x \equiv 3 (\mod 5)ï¼Œ$$x \equiv 2 (\mod 7)$    

ï¼ˆ1ï¼‰æŠŠç¬¬1ä¸ªè½¬æ¢ä¸º$x = 2+ 3t$ï¼Œä»£å…¥ç¬¬2ä¸ªå½“ä¸­ï¼Œ$2 + 3t \equiv 3(\mod 5)$ã€‚

ï¼ˆ2ï¼‰æ±‚è§£$2+3t \equiv 3(\mod 5)$ï¼Œå³$3t \equiv 1(\mod 5)$ï¼Œå› ä¸º$gcd(3,5)$èƒ½æ•´é™¤1ï¼Œæ‰€ä»¥æœ‰è§£ã€‚ç„¶åæ±‚è§£$3t \equiv 1(\mod 5)$ï¼Œå…ˆæ±‚3æ¨¡5çš„é€†ï¼Œç»“æœä¸º2ï¼Œæ‰€ä»¥è§£å¾—$t \equiv 2(\mod 5)$ï¼Œç„¶åä¸æ–­è½¬æ¢ã€‚

ï¼ˆ3ï¼‰æœ€ååˆå¹¶ç»“æœå¾—åˆ°ï¼Œ$x \equiv 23(\mod 105)$ã€‚

###### æ´›è°·P4777

ç»™å®š $n$ ç»„éè´Ÿæ•´æ•° $a_i, b_i$ ï¼Œæ±‚è§£å…³äº $x$ çš„æ–¹ç¨‹ç»„çš„æœ€å°éè´Ÿæ•´æ•°è§£ã€‚
$$\begin{cases}x\equiv b_1\pmod{a_1}\\x\equiv b_2\pmod{a_2}\\\dots\\x\equiv b_n\pmod{a_n}\end{cases}$$

```c++
#include <bits/stdc++.h>
using namespace std;
long long ai[100010];
long long mi[100010];
int n;
long long mul(long long a,long long b,long long m)
{
	long long res = 0;
	while(b > 0)
	{
		if(b&1)
			res = (res + a) % m;
		a = (a + a)%m;
		b>>=1;
	}
	return res;
}
long long extend_gcd(long long a,long long b,long long &x,long long &y)
{
	if(b == 0)
	{
		x = 1;
		y = 0;
		return a;
	}
	long long d = extend_gcd(b,a%b,y,x);
	y -= a / b * x;
	return d;
}
long long excrt()
{
	long long x,y;
	long long m1 = mi[1],a1 = ai[1];//ç¬¬ä¸€ä¸ªç­‰å¼ã€‚
	long long ans = 0;
	for(int i = 2;i <= n;i++)
	{
		long long a2 = ai[i],m2 = mi[i];
        long long a = m1,b = m2,c = (a2 - a1 % m2 + m2) % m2;
        long long d = extend_gcd(a,b,x,y);
        if(c%d != 0)//æ— è§£
        	return - 1;
        x = mul(x,c/d,b/d);
        ans = a1 + x * m1;
        m1 = m2 / d * m1;
        ans = (ans % m1 + m1) % m1;
        a1 = ans;
	}
	return ans;
}
int main ()
{
	cin>>n;
	for(int i = 1;i <= n;i++)
	{
		cin>>mi[i]>>ai[i];
	}
	cout<<excrt();
}
```

## ç´ æ•°

### ç´ æ•°åˆ¤å®š

å½“$n<10^{12}$ï¼Œé‡‡ç”¨è¯•é™¤æ³•ï¼Œå¤§äºæ—¶ï¼Œé‡‡ç”¨Miller_Rabinã€‚

```cpp
bool is_prime(long long n)
{
	if(n <= 1)
		return false;
	for(long long i = 2;i<= sqrt(n);i++)//i*i<=n
	{
		if(n % i ==0)
			return false;
	}
    return true;
}
```

#### è´¹é©¬ç´ æ€§æµ‹è¯•

é€šè¿‡è´¹é©¬å°å®šç†çš„é€†å®šç†çš„å‡ ä¹æˆç«‹ï¼Œå¯ä»¥å¾—å‡ºè´¹é©¬ç´ æ€§æµ‹è¯•ã€‚

ä¸ºäº†æµ‹è¯•næ˜¯å¦ä¸ºç´ æ•°ï¼Œåœ¨1~nä»»é€‰ä¸€ä¸ªéšæœºçš„åŸºå€¼aï¼Œæ³¨æ„aå¹¶ä¸éœ€è¦ä¸näº’ç´ ã€‚

ï¼ˆ1ï¼‰å¦‚æœ$a^{n-1}\equiv 1(\mod n)$ä¸æˆç«‹ï¼Œé‚£ä¹ˆnè‚¯å®šä¸æ˜¯ç´ æ•°ã€‚è¿™å®é™…ä¸Šæ˜¯è´¹é©¬å°å®šç†çš„é€†å¦å‘½é¢˜ã€‚

ï¼ˆ2ï¼‰å¦‚æœ$a^{n-1}\equiv 1(\mod n)$æˆç«‹ï¼Œé‚£ä¹ˆnå¾ˆå¤§æ¦‚ç‡æ˜¯ç´ æ•°ã€‚å°è¯•çš„aè¶Šå¤šï¼Œæ¦‚ç‡è¶Šå¤§ã€‚ç§°næ˜¯ä¸€ä¸ªåŸºäºaçš„ä¼ªç´ æ•°ã€‚

ç„¶è€Œå¹¶ä¸æ˜¯å®Œå…¨æ­£ç¡®çš„ï¼Œæœ‰ä¸€äº›åˆæ•°èƒ½è¢«è¯¯åˆ¤é€šè¿‡ï¼Œä¸åŒçš„aå€¼ï¼Œè¢«è¯¯åˆ¤çš„åˆæ•°ä¸å¤ªä¸€æ ·ã€‚ç‰¹åˆ«åœ°ï¼Œæœ‰ä¸€äº›åˆæ•°ï¼Œä¸ç®¡aé€‰ä»€ä¹ˆï¼Œéƒ½èƒ½é€šè¿‡æµ‹è¯•ã€‚è¿™ç§æ•°å«åšCarmichaelæ•°ï¼Œå‰3ä¸ªCarmichaelæ•°æ˜¯561ã€1105ã€1729ã€‚ä¸è¿‡ï¼ŒCarmichaelæ•°æ•°å¾ˆå°‘ï¼Œå‰1äº¿ä¸ªæ­£æ•´æ•°ä¸­åªæœ‰255ä¸ªã€‚

#### Miller-Rabinç´ æ€§æµ‹è¯•

Miller-Rabinç´ æ€§æµ‹è¯•ä¸ºè´¹é©¬æµ‹è¯•æ’é™¤Carmichaelæ•°ã€‚

##### äºŒæ¬¡æ¢æµ‹å®šç† 

å¦‚æœpæ˜¯ä¸€ä¸ªå¥‡ç´ æ•°ï¼Œä¸”$e\geqslant 1$ï¼Œåˆ™æ–¹ç¨‹$x^2 \equiv 1(\mod p^e)$ä»…æœ‰ä¸¤ä¸ªè§£ï¼š$x = 1$å’Œ$x = -1$ã€‚å½“$e = 1$æ—¶ï¼Œæ–¹ç¨‹$x^2 \equiv 1(\mod p)$ä»…æœ‰ä¸¤ä¸ªè§£$x = 1$å’Œ$x = p - 1$ã€‚

æŠŠ$x = 1$å’Œ$x = p - 1$ç§°ä¸º"xå¯¹æ¨¡pæ¥è¯´1çš„å¹³å‡¡å¹³æ–¹æ ¹"ã€‚å¦‚æœå¯¹æ¨¡nå­˜åœ¨1çš„éå¹³å‡¡å¹³æ–¹æ ¹ï¼Œåˆ™næ˜¯åˆæ•°ã€‚

```c++
#include <bits/stdc++.h>

using namespace std;
long long fast_pow(long long x,long long y,int m)
{
	long long res = 1;
	x = x % m;
	while(y)
	{
		if(y&1)
			res = (res * x) % m;
		x = (x * x) % m;
		y >>= 1;
	}
	return res;
}
bool witness(long long a,long long b)//ç´ æ€§æµ‹è¯•ï¼Œè¿”å›trueè¡¨ç¤ºnæ˜¯åˆæ•°
{
	long long u = n - 1;//uæ˜¯n-1çš„äºŒè¿›åˆ¶å»æ‰æœ«å°¾0
	int t = 0;//n-1çš„äºŒè¿›åˆ¶ï¼Œæ˜¯å¥‡æ•°uçš„äºŒè¿›åˆ¶åé¢åŠ tä¸ª0
	while(u&1 == 0)//æ•´æ•°n-1æœ«å°¾0çš„ä¸ªæ•°å°±æ˜¯t
	{
		u = u>>1;
		t++;
	}
	long long x1,x2;
	x1 = fast_pow(a,u,n);
	for(int i = 1;i <= t;i++) //å¹³æ–¹å–æ¨¡
	{
		 x2 = fast_pow(x1,2,n);
		 if(x2 == 1&&x1 != 1&&x1 != n-1)
		 {
		 	return true;
		 }
		 x1 = x2;
	}
	if(x1 != -1)
		return true;//ç”¨è´¹é©¬æµ‹è¯•åˆ¤æ–­æ˜¯å¦ä¸ºåˆæ•°
	return false;
}
int miller_rabin(long long n,int s)
{
	if(n < 2)
		return 0;
	if(n == 2)
		return 1;
	if(n%2==0)
		return 0;
	for(int i = 0;i < s &&i < n;i++)//sæ¬¡æµ‹è¯•
	{
		long long a = rand()%(n-1) + 1; //aä¸ºéšæœºæ•°
		if(witness(a,n))
			return 0;
	}
	return 1;
}
int main()
{
	int m;
	cin>>m;
	int cnt = 0;
	for(int i = 0;i < m;i++)
	{
		long long n;
		cin>>n;
		int s = 50//50æ¬¡æµ‹è¯•
		cnt += miller_rabin(n,s);
	}
	cout<<cnt;
}
```

### ç´ æ•°ç­›

#### åŸƒå¼ç­›

```c++
int prime[N+1];//å‚¨å­˜ç´ æ•°
bool visit[N+1];//trueè¡¨ç¤ºè¢«ç­›æ‰ï¼Œä¸æ˜¯ç´ æ•°
int E_sieve(int n)
{
    for(int i = 0;i <= n;i++)
    {
        visit[i] = false;
      
    }
    for(int i = 2;i * i <= n;i++)
    {
        if(!visit[i])
        {
            for(int j = i*i;j <= n;j+=i)
            {
                visit[j] = true;//æ ‡è®°ä¸ºéç´ æ•°
			}
        }
    }
    int k =  0;//è®°å½•ç´ æ•°ä¸ªæ•°
    for(int i = 2;i <= n;i++)
    {
        if(!visit[i])
            prime[k++] = i;
       return k;
    }
}
```

#### æ¬§å¼ç­›

```c++
int prime[N+1];
bool vis[N+1];
int euler_sieve(int n)
{
	int cnt = 0;
	memset(vis, 0, sizeof(vis));
	memset(prime,0,sizeof(prime));
	for(int i = 2;i <= n;i++)
	{
		if(!vis[i])
			prime[cnt++] = i;
		for(int j = 0;j < cnt;j++)
		{
			if(i * prime[i] > n)
				break;
			vis[i * prime[j]] = 1;
			if(i % prime[j] == 0)//å¦‚æœièƒ½æ•´é™¤å®ƒï¼Œè¡¨æ˜iè‚¯å®šä¸æ˜¯xçš„æœ€å°è´¨å› æ•°
				break;
		}
	}
}
```

### è´¨å› æ•°åˆ†è§£

#### æ¬§æ‹‰ç­›æ±‚æœ€å°å…±å› æ•°

æ±‚1~n çš„æ¯ä¸ªæ•°çš„æœ€å°è´¨å› æ•°ã€‚

```
int prime[N+1];
bool vis[N+1];
int euler_sieve(int n)
{
	int cnt = 0;
	memset(vis, 0, sizeof(vis));
	memset(prime,0,sizeof(prime));
	for(int i = 2;i <= n;i++)
	{
		if(!vis[i])
		{
			vis[i] = i;//è®°å½•æœ€å°è´¨å› æ•°
        	prime[cnt++] = i;
		
		}
		for(int j = 0;j < cnt;j++)
		{
			if(i * prime[i] > n)
				break;
			vis[i * prime[j]] = prime[j];//è®°å½•æœ€å°è´¨å› æ•°
			if(i % prime[j] == 0)//å¦‚æœièƒ½æ•´é™¤å®ƒï¼Œè¡¨æ˜iè‚¯å®šä¸æ˜¯xçš„æœ€å°è´¨å› æ•°
				break;
		}
	}
}
```

#### è¯•é™¤æ³•

è¯•é™¤æ³•æ±‚nçš„è´¨å› æ•°ã€‚

ï¼ˆ1ï¼‰æ±‚æœ€å°è´¨å› æ•°$p_1$ã€‚æ£€æµ‹$2$~$\sqrt n$çš„æ‰€æœ‰ç´ æ•°ï¼Œå¦‚æœå®ƒèƒ½æ•´é™¤nï¼Œå°±æ˜¯æœ€å°è´¨å› æ•°ï¼Œç„¶åè¿ç»­ç”¨$p_1$é™¤nï¼Œå»æ‰nä¸­çš„$p_1$ï¼Œå¾—åˆ°$n_1$ã€‚

ï¼ˆ2ï¼‰å†æ‰¾$n_1$çš„æœ€å°è´¨å› æ•°ã€‚é€ä¸ªæ£€æŸ¥$p_1$~$\sqrt n$çš„æ‰€æœ‰ç´ æ•°ã€‚

ï¼ˆ3ï¼‰ä¸€ç›´æŒç»­ï¼Œç›´åˆ°æ‰¾åˆ°æ‰€æœ‰è´¨å› æ•°ã€‚

å¦‚æœæœ€åå‰©ä¸‹ä¸€ä¸ªå¤§äº1çš„æ•°ï¼Œé‚£ä¹ˆå®ƒä¹Ÿæ˜¯ä¸€ä¸ªç´ æ•°ã€‚

```cpp
int p[20];//è®°å½•å› æ•°ï¼Œp[1]ä¸ºæœ€å°å› æ•°
int c[40];//è®°å½•ç¬¬iä¸ªå› æ•°çš„ä¸ªæ•°ï¼Œ
int  factor(int n)
{
	int m = 0;
	for(int i = 2;i <= sqrt(n);i++)
	{
		if(n % i == 0)
		{
			p[++m] = i;
			c[m] = 0;
			while(n % i== 0)//æŠŠnä¸­é‡å¤çš„å»æ‰
			{
				n = n / i;
				c[m]++;//å»ä¸€æ¬¡ä¸ªæ•°åŠ 1
			}
		}
	}
	if(n > 1)
	{
		p[++m] = n;
		c[m] = 1;
	}
	return m;
}
```

#### pollard_rhoå¯å‘å¼åˆ†è§£

```c++
long long Gcd(long long a,long long b)
{
	return b ? Gcd(b,a % b):a;
}
long long mult_mod(long long a,long long b,long long n)
{
	a = a%n;
	b = b%n;
	long long ret = 0;
	while(b)
	{
		if(b&1)
		{
			ret += a;
			if(ret >= n)
				ret -= n;
		}
		a<<=1;
		if(a>=n)
			a-=n;
		b>>=1;
	}
	return ret;
}
long long pollard_rho (long long n)
{
	long long i = 1,k = 2;
	long long c = rand()%(n-1) + 1;
	long long x = rand()%n;
	long long y = x;
	while(true)
	{
		i++;
		x = (mult_mod(x,x,n) + c) % n;
		long long d = Gcd(y > x ? y - x:x - y,n);
		if(d != 1&&d!=n)
			return d;
		if(y == x)
			return n;
		if(i == k)
		{
			y = x;
			k = k<<1;
		}
	}
}
void findfac (long long n)
{
	if(miller_rabin(n))
	{
		factor[tol++] = n;
		return;
	}
	long long p = n;
	while(p >= n)
		p = pollard_rho(p);
	findfac(p);
	findfac(n / p);
}
```

## å¨å°”é€Šå®šç†

è‹¥pä¸ºç´ æ•°ï¼Œåˆ™på¯ä»¥æ•´é™¤$(p-1)! + 1$ã€‚

ï¼ˆ1ï¼‰$((p-1)!+1)\mod p=0$

ï¼ˆ2ï¼‰$(p-1)!\mod p = p -1$

ï¼ˆ3ï¼‰$(p - 1)! = pq-1$

ï¼ˆ4ï¼‰ç”¨åŒä½™è¡¨ç¤ºä¸º$(p-1)!\equiv -1(\mod p)$ã€‚

## æ¬§æ‹‰å‡½æ•°

è®¾næ˜¯ä¸€ä¸ªæ­£æ•´æ•°ï¼Œæ¬§æ‹‰å‡½æ•°$\phi(n)$å®šä¹‰ä¸ºä¸è¶…è¿‡nä¸”ä¸näº’ç´ çš„æ­£æ•´æ•°çš„ä¸ªæ•°ã€‚
$$
\phi(n) = \sum\limits_{i=1}^{n}[gcd(i,n) = 1]
$$
å®šç†1 è®¾på’Œqæ˜¯äº’ç´ çš„æ­£æ•´æ•°ï¼Œé‚£ä¹ˆ$\phi(pq)=\phi(p)\phi(q)$ã€‚

å®šç†2 è®¾nä¸ºæ­£æ•´æ•°ï¼Œé‚£ä¹ˆ
$$
n = \sum\limits_{d|n}\phi(d)
$$
å…¶ä¸­ï¼Œd|nè¡¨ç¤ºdæ•´é™¤nï¼Œä¸Šå¼è¡¨ç¤ºå¯¹nçš„æ­£å› æ•°æ±‚å’Œã€‚ä¾‹å¦‚n=12ï¼Œé‚£ä¹ˆdæ˜¯1ï¼Œ2ï¼Œ3ï¼Œ4ï¼Œ6ï¼Œ12ã€‚

æœ‰$12=\phi(1)+\phi(2)+\phi(3)+\phi(4)+\phi(6)+\phi(12)$ã€‚

æ¬§æ‹‰å‡½æ•°æ±‚è§£

æ¬§æ‹‰å®šç† è®¾mæ˜¯ä¸€ä¸ªæ­£æ•´æ•°ï¼Œaæ˜¯ä¸€ä¸ªæ•´æ•°ä¸”aä¸mäº’ç´ ï¼Œå³$gcd(a,m) = 1$ï¼Œåˆ™æœ‰$a^{\phi(m)} \equiv 1(\mod m)$ã€‚

æ¬§æ‹‰å‡½æ•°é€šè§£$\phi (n) = n(1-\frac{1}{p_1})(1-\frac{1}{p_2})â€¦â€¦(1-\frac{1}{p_k})=n\prod_\limits{i=1}^k(1-\frac{1}{p_i})$ã€‚

è¯•é™¤æ³•

```c++
int euler(int n)
{
	int ans = n;
	for(int p = 2;p * p <= n;++p)
	{
		if(n % p == 0)
		{
			ans = ans / p*(p-1);
			while(n % p == 0)
				n /= p;
		}
	}
	if(n != 1)
		ans = ans / n*(n-1);
	return ans;
}
```

æ¬§æ‹‰ç­›

æ±‚è§£1~nå†…çš„æ‰€æœ‰æ¬§æ‹‰å‡½æ•°

```c++
int vis[N];//è®°å½•æœ€å°è´¨å› æ•°
int prime[N];//è®°å½•ç´ æ•°
int phi[N];//è®°å½•æ¬§æ‹‰å‡½æ•°
int sum[N];//æ¬§æ‹‰å‡½æ•°å’Œ
void euler (int n)
{
    int cnt = 0;
	for(int i = 2;i < n;i++)
    {
        if(!vis[i])
        {
            vis[i] = i;
            prime[cnt++]=i;//è®°å½•ç´ æ•°
            phi[i] = i - 1;
        }
        for(int j = 0;j < cnt;j++)
        {
            if(i * prime[j] > n)
                break;
            vis[i * prime[j]] = prime[j];//è®°å½•æœ€å°è´¨å› æ•°
            if(i % prime[j] == 0)
            {
                phi[i * prime[j]] = phi[i] * prime[j];
                break;
			}
            phi[i * prime[j]] = phi[i] * phi[prime[j]];
		}
	}
}
```

## ç‹„åˆ©å…‹é›·å·ç§¯

è®¾få’Œgç®—æœ¯å‡½æ•°ï¼Œè®°få’Œgçš„ç‹„åˆ©å…‹é›·å·ç§¯ä¸ºfã€$f *g$ï¼Œå®šä¹‰ä¸º
$$
(f*g)(n) = \sum\limits_{d|n}f(d)g(\frac{n}{d})
$$
å®šä¹‰æ’ç­‰å‡½æ•°$I(n) = n$ã€å¸¸æ•°å‡½æ•°$1(n) = 1$ï¼Œä»–ä»¬å·ç§¯æ˜¯
$$
(I*1)(N) = \sum\limits_{d|n}I(d)1(\frac{n}{d})=\sum\limits_{d|n}d*1=\sum\limits_{d|n}d=\sigma(n)
$$
æŠŠå®ƒè®°ä¸º$I*1=\sigma$ã€‚$\sigma(n)$æ˜¯â€œå› æ•°å’Œå‡½æ•°â€çš„ç¬¦å·ã€‚

## è«æ¯”ä¹Œæ–¯

è«æ¯”ä¹Œæ–¯å‡½æ•°$\mu(n)$å®šä¹‰ä¸º
$$
\mu(n)=\begin{cases}
1,&n=1\\(-1)^r,&n=p_1p_2â€¦â€¦p_rï¼Œå…¶ä¸­p_iä¸ºä¸åŒå‘çš„ç´ æ•°\\0ï¼Œ&å…¶ä»–
\end{cases}
$$
è«æ¯”ä¹Œæ–¯å‡½æ•°çš„å’Œå‡½æ•°åœ¨æ•´æ•°nå¤„çš„å€¼$F(n) = \sum\limits_{d|n}\mu(d)$ï¼Œæ»¡è¶³
$$
\sum\limits_{d|n}\mu(d)=\mu(n)=\begin{cases}
1,&n=1\\0ï¼Œ&n > 1
\end{cases}
$$
çº¿æ€§ç­›æ±‚1~nçš„è«æ¯”ä¹Œæ–¯å‡½æ•°

```c++
bool  vis[N];
int prime[N];
int Mob[N];
void Mobius_sieve()
{
	int cnt = 0;
	vis[1] = 1;
	Mob[1] = 1;
	for(int i = 2;i <= n;i++)
	{
		if(!vis[i])
		{
			prime[cnt++] = i;
			Mob[i] = -1;
		}
		for(int j = 0;i < cnt&&1LL * prime[j] * i <= n;j++)
		{
			vis[prime[j] * i] = 1;
			Mob[i*prime[j]] = (i % prime[j]) ? -Mob[i] :0);
			if(i % prime[j] == 0)
				break;
		}
	}
}
```

### è«æ¯”ä¹Œæ–¯åæ¼”

è‹¥fæ˜¯ç®—æœ¯å‡½æ•°ï¼ŒFä¸ºfçš„å’Œå‡½æ•°ï¼Œå¯¹ä»»æ„æ­£æ•´æ•°nï¼Œæ»¡è¶³$F(n) = \sum\limits_{d|n}f(d)$ï¼Œåˆ™æœ‰$f(n)=\sum\limits_{d|n}\mu(d)F(\frac{n}{d})$ã€‚

ä½¿ç”¨è«æ¯”ä¹Œæ–¯åæ¼”æ±‚æ¬§æ‹‰å‡½æ•°

```c++
int phi[N];
vector<int> fac[N];
void get_eulers()
{
	for(int i = 1;i <= n - 10;i++)
	{
		for(int j = i;j <= n - 10;j+=i)
		{
			fac[j].push_back(i);
		}
	}
	phi[1] = 1;
	for(int i = 2;i <= n - 10;i++)
	{
		phi[i] = i;
		for(auto j : fac[i])
		{
			if(j == i)
			{
				continue;
			}
			phi[i] -= phi[j];
		}
	}
}
```

## æœæ•™ç­›

```c++
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
const int N = 5e6+7;
int prime[N];
bool vis[N];
int mu[N];
ll phi[N];
unordered_map<int,int>summu;
unordered_map<int,ll>sumphi;
void init()
{
    int cnt = 0;
    vis[0] = vis[1] = 1;
    mu[1] = phi[1] = 1;
    for(int i = 2;i < N;i++)
    {
        if(!vis[i])
        {
            prime[cnt++] = i;
            mu[i] = -1;
            phi[i] = i - 1;
        }
        for(int j = 0;j < cnt&&i * prime[j] < N;j++)
        {
            vis[i * prime[j]] = 1;
            if(i % prime[j])
            {
                mu[i * prime[j]] = -mu[i];
                phi[i * prime[j]] = phi[i] * phi[prime[j]];
            }
            else
            {
                mu[i * prime[j]] = 0;
                phi[i * prime[j]] = phi[i] * prime[j];
                break;
            }
        }
    }
    for(int i = 1;i < N;i++)
    {
        mu[i] += mu[i - 1];
        phi[i] += phi[i - 1];
    }
}
int gsum(int x)
{
    return x;
}
ll getsmu(int x)
{
    if(x < N)
        return mu[x];
    if(summu[x])
        return summu[x];
    ll ans = 1;
    for(ll l = 2,r;l <= x;l = r + 1)
    {
        r = x /(x/ l);
        ans -= (gsum(r) - gsum(l - 1)) * getsmu(x/l);
    }
    return summu[x] = ans / gsum(1);
}
ll getsphi(int x)
{
    if(x < N)
        return phi[x];
    if(sumphi[x])
        return sumphi[x];
    ll ans = x*((ll)x+ 1 ) / 2;
    for(ll l = 2,r;l <= x;l = r + 1)
    {
        r = x/(x/l);
    	ans -= (gsum(r)-gsum(l - 1))*getsphi(x/l);
    }
    return sumphi[x] = ans/gsum(1);
}
int main ()
{
    init();
    int t;
    cin>>t;
    while(t--)
    {
        int n;
        cin>>n;
        cout<<getsphi(n)<<" "<<getsmu(n)<<endl;
    }
}
```

# ç»„åˆæ•°å­¦

### å¡ç‰¹å…°æ•°



C0 = 1,         
C1 = 1,         C2 = 2,          C3 = 5,          C4 = 14,          C5 = 42,
C6 = 132,       C7 = 429,        C8 = 1430,       C9 = 4862,        C10 = 16796,
C11 = 58786,    C12 = 208012,    C13 = 742900,    C14 = 2674440,    C15 = 9694845,
C16 = 35357670, C17 = 129644790, C18 = 477638700, C19 = 1767263190, C20 = 6564120420, ...

äºŒé¡¹å¼å®šç†

æ±‚äºŒé¡¹å¼ç³»æ•°æ–¹æ³•

1.é€’æ¨å…¬å¼$C^r_n = C^r_{n-1} + C^{r-1}_{n-1}$æ—¶é—´å¤æ‚åº¦$O(n^2)$;

2.ä½¿ç”¨é€†è®¡ç®—ï¼Œ$C^r_n =\begin{pmatrix}n\\r\end{pmatrix} = \frac{n!}{r!(n-r)!}$ã€‚$C^r_n\mod m =\frac{n!}{r!(n-r)!} \mod m=(n!\mod m)((r!)^{-1}\mod m)((n-r)!)^{-1}\mod m)\mod m$ã€‚

è¾“å‡ºæ¨è¾‰ä¸‰è§’å‰nè¡Œ

```c++
#include <bits/stdc++.h>
using namespace std;

int a[21][21];
int main ()
{
	int n;
	cin>>n;
	for(int i = 1;i <= n;i++)
		a[i][1] = a[i][i] = 1;
	for(int i = 1;i <= n;i++)
		for(int j = 2;j < i;j++)
			a[i][j] = a[i-1][j] + a[i-1][j-1];
	for(int i = 1;i <= n;i++)
	{
		for(int j = 1;j <= i;j++)
			cout<<a[i][j]<<"  ";
		cout<<"\n";
	}
	return 0;
}
```

P1313

ç»™å®šå¤šé¡¹å¼$(ax+by)^k$ï¼Œæ±‚å¤šé¡¹å¼å±•å¼€åç¬¬$x^n*y^m$é¡¹çš„ç³»æ•°ã€‚

$(ax+by)^k=\sum\limits_{r=1}^kC_k^r(ax)^r(by)^{k-r}=\sum\limits_{r=1}^kC_k^ra^rx^rb^{k-r}y^{k-r}=\sum\limits_{r=1}^k(C_k^ra^rb^{k-r})x^ry^{k-r}$ã€‚

```c++
#include <bits/stdc++.h>
using namespace std;
#define mod 10007
int fac[10001];//é˜¶ä¹˜
int inv[10001];//é€†å…ƒ
int fastPow(int a,int b)
{
	int ans = 1;
	a = a % mod;
	while(b)
	{
		if(b & 1)
		{
			ans = ans * a %mod;
		}
		a = a *a %mod;
		b = b>>1;
	}
	return ans;

}
int C(int n,int m)\\è®¡ç®—ç»„åˆæ•°
{
	return (fac[n] * inv[m] % mod *inv[n - m] % mod) % mod;
} 
int main ()
{
	int a,b,n,m,k,ans;
	cin>>a>>b>>k>>n>>m;
	fac[0] = 1;
	for(int i = 1;i <= n + m;i++)
	{
		fac[i] = (fac[i - 1] * i)%mod;
		inv[i] = fastPow(fac[i],mod - 2);
	}	
	ans = (fastPow(a,n) % mod * fastPow(b,m) % mod *C(k,n) % mod) %mod;
	cout<<ans;
	return 0;
}
```



# ä½è¿ç®—

ä½è¿ç®—ä¸­çš„æ€è·¯ã€‚è€ƒè™‘è¿ç®—è¿‡ç¨‹ä¹‹é—´çš„ä½æ˜¯å¦æœ‰å½±å“ï¼Œå³æ˜¯å¦è¿›ä½ï¼Œå‡æ³•è‚¯å®šä¸ä¼šè¿›ä½ï¼Œéœ€è¦è€ƒè™‘æ˜¯å¦ç»“æœä¸º-1ï¼Œå³ä½¿å€Ÿä½ï¼Œè€ŒåŠ æ³•éœ€è¦è€ƒè™‘è¿›ä½ï¼Œå³ç»“æœä¸º2ã€‚å¦‚æœæ²¡æœ‰å½±å“ï¼Œé‚£ä¹ˆå¯ä»¥åˆ—å‡ºçœŸå€¼è¡¨æ„é€ ç»“æœã€‚

ä½è¿ç®—ä¸­çš„2è¿›åˆ¶åº”è¯¥æ˜¯å·¦ç§»æˆ–è€…å³ç§»æ¥æ¨¡æ‹Ÿã€‚

## ä¸

é€šè¿‡ä¸1ã€10ã€100ã€è¿ç®—ï¼Œå¯ä»¥çŸ¥é“å½“å‰ä½æ•°çš„å¯¹åº”çš„å€¼ã€‚

åˆ¤æ–­nä¸ªæ•°å­—çš„ä½å€¼æ˜¯å¦ç­‰äºç‰¹å®šçš„å€¼

æ¯”å¦‚éœ€è¦åˆ¤æ–­aã€bã€cçš„ä½æ•°ç­‰äº1ã€0ã€0ã€‚é€šè¿‡ä¸è¿ç®—æ„é€ ä¸çš„ç»“æœä¸º1å³å¯ã€‚

```c++
if(a&!b&!c)
```



## å¼‚æˆ–

Y=Aâ€™â‹…B+Aâ‹…Bâ€™

æ’ç­‰å¾‹ï¼šX âŠ• 0 = X

å½’ é›¶ å¾‹ ï¼š X âŠ• X = 0 

æ€§è´¨

â‘  è‡ªåæ€§ï¼š$a âŠ• b âŠ• b = a$

â‘¡ æ— åºæ€§ï¼š$a âŠ• b âŠ• c âŠ• d = bâŠ• d âŠ• a âŠ• c$

â‘¢ å¯ç§»é¡¹æ€§ï¼š$a âŠ• b = c$ å¯ç§»é¡¹ä¸º $a = b âŠ• c$ï¼Œç§»é¡¹æ—¶æ— éœ€æ”¹å˜ç¬¦å·

â‘£ ä½ç‹¬ç«‹æ€§ï¼šæ¯ä¸€ä½çš„å¼‚æˆ–äº’ç›¸ç‹¬ç«‹ï¼Œæ¯”å¦‚ $1010 âŠ• 1110 = 0100$

**ä¾‹1**ï¼šç»™å®šä¸€ä¸ªæ•°ç»„ï¼Œé™¤äº†æŸä¸ªå…ƒç´ åªå‡ºç°ä¸€æ¬¡ä»¥å¤–ï¼Œå…¶ä½™æ¯ä¸ªå…ƒç´ å‡å‡ºç°ä¸¤æ¬¡ã€‚æ‰¾å‡ºåªå‡ºä¸€æ¬¡çš„å…ƒç´ 

è§£ï¼šå¼‚æˆ–ä¸¤æ¬¡ä¸å˜æ‰¾å‡ºæœ€åçš„ç»“æœï¼Œè‡ªåæ€§+æ— åºæ€§ã€‚

**ä¾‹2**ï¼šå¼‚æˆ–å‰ç¼€å’Œã€‚ç»™å®šä¸€ä¸ªéç©ºæ•´æ•°æ•°ç»„ï¼Œè¯·ä½ æ±‚å‡ºæŒ‡å®šå­æ•°ç»„çš„æ‰€æœ‰å…ƒç´ å¼‚æˆ–ä¹‹å’Œã€‚

```c++
int a
//æ„é€ å¼‚æˆ–å‰ç¼€å’Œæ•°ç»„
for(int i = 0;i < arr.length;i++)
{
	prexorsum[i + 1] = prexorsum[i] ^ arr[i];
}
//ä½¿ç”¨å¼‚æˆ–å‰ç¼€å’Œæ•°ç»„
for(int i = 0;i , )
```

# åšå¼ˆè®º

## å–å­æ¸¸æˆ

æ­¥éª¤1:å°†æ‰€æœ‰ç»ˆç»“ä½ç½®æ ‡è®°ä¸ºå¿…è´¥ç‚¹ï¼ˆPç‚¹ï¼‰ã€‚

æ­¥éª¤2:å°†æ‰€æœ‰ä¸€æ­¥æ“ä½œèƒ½è¿›å…¥å¿…è´¥ç‚¹(Pç‚¹ï¼‰çš„ä½ç½®æ ‡è®°ä¸ºå¿…èƒœç‚¹(Nç‚¹)

æ­¥éª¤3:å¦‚æœä»æŸä¸ªç‚¹å¼€å§‹çš„æ‰€æœ‰ä¸€æ­¥æ“ä½œéƒ½åªèƒ½è¿›å…¥å¿…èƒœç‚¹(Nç‚¹ï¼‰ï¼Œåˆ™å°†è¯¥ç‚¹æ ‡è®°ä¸ºå¿…è´¥ç‚¹(Pç‚¹)ã€‚

æ­¥éª¤4:å¦‚æœåœ¨æ­¥éª¤3æœªèƒ½æ‰¾åˆ°æ–°çš„å¿…è´¥(Pç‚¹ï¼‰ï¼Œåˆ™ç®—æ³•ç»ˆæ­¢;å¦åˆ™ï¼Œè¿”å›åˆ°æ­¥éª¤2ã€‚

ä¾‹å¦‚$S=\{1,3,4\}$,å…ˆæ‹¿å®Œçš„èƒœåˆ©

å¯ä»¥çœ‹å‡º1åˆ°10ä¹‹é—´çš„På’ŒNç‚¹

$0\ 1\  2\ 3\ 4\ 5\ 6\ 7\ 8\ 9\ 10$

$PNPNNNNPNPN $

## Nimæ¸¸æˆ

ä¸‰å †çŸ³å¤´ï¼Œè½®æµä»æŸå †å–ï¼Œå¯å–ä»»æ„æ•°é‡ï¼Œæœ€åå–å®Œçš„èƒœåˆ©ã€‚

å¯¹äºNimæ¸¸æˆçš„æŸä¸ªä½ç½®å½“ä¸”ä»…å½“å„éƒ¨åˆ†çš„nim-sumç­‰äº0çš„æ—¶å€™ï¼Œ$aâŠ•bâŠ•c=0$ï¼Œåˆ™å½“å‰ä½äºå¿…è´¥ç‚¹ã€‚

å¯¹äºå¿…èƒœç‚¹ï¼Œåˆ¤æ–­å¯è¡Œçš„æ–¹æ¡ˆã€‚

ä¾‹å¦‚$aâŠ•bâŠ•c=S$,æ­¤æ—¶Sä¸ç­‰äº0ï¼Œé‚£ä¹ˆå…ˆæ‰‹å¿…é¡»å°†ä»–å˜æˆ0ã€‚æ­¤æ—¶éœ€è¦Såˆ†åˆ«äºä¸Šé¢çš„abcå¼‚æˆ–ï¼Œ å¦‚æœç»“æœå˜å°äº†ï¼Œé‚£ä¹ˆå°±æ˜¯è¦æ‰¾çš„ç›®æ ‡ã€‚

## SGå‡½æ•°

XèŠ‚ç‚¹çš„SGå€¼æ˜¯å»é™¤Xçš„åç»§èŠ‚ç‚¹çš„SGå€¼åçš„æœ€å°çš„éè´Ÿæ•´æ•°ã€‚

å¿…è´¥ç‚¹ï¼šå½“èŠ‚ç‚¹xçš„sg(x) = 0ï¼Œå¿…èƒœç‚¹ï¼šå½“èŠ‚ç‚¹xçš„sg(x) > 0

ä¾‹å¦‚$S=\{1,2,3\}$ã€‚$sg(0) = 0$,1çš„åç»§åªæœ‰0é‚£ä¹ˆ$sg(1) = 1$ï¼Œ$sg(2) = 2,sg(3) = 3,sg(4)=0,sg(5)=1$ã€‚

å¦‚æœå›¾æ¸¸æˆGç”±è‹¥å¹²å­å›¾æ¸¸æˆGiç»„æˆï¼Œå³ï¼š$G=G_1+â€¦â€¦+G_n$,è®¾$g_i$æ˜¯$G_i(i=1,â€¦â€¦,n)$çš„SGå‡½æ•°å€¼ï¼Œé‚£ä¹ˆå¤§æ¸¸æˆçš„æ€»sgå€¼ç­‰äºæ¯ä¸ªå­æ¸¸æˆçš„sgå€¼çš„å¼‚æˆ–å’Œï¼Œ$g(x_1,â€¦â€¦,x_n)=g_1(x_1)âŠ•â€¦â€¦âŠ•g_n(x_n)$ 



# STL

## STLç®—æ³•

### sortå‡½æ•°

### accumulateå‡½æ•°

ç´¯åŠ å‡½æ•°ï¼Œç»™å®šä¸‰ä¸ªå‚æ•°ï¼Œå‰ä¸¤ä¸ªä¸ºå…ƒç´ èŒƒå›´ï¼Œæœ€åä¸€ä¸ªä¸ºç´¯åŠ åˆå€¼ã€‚æœ€åç»“æœä¸ºç´¯åŠ åˆå§‹å€¼+å…ƒç´ èŒƒå›´å†…æ‰€æœ‰å…ƒç´ å’Œ

```c++
vector<int> a = {3,2,1};
cout<<accumulate(a.begin(),a.end(),1);
//7
```

ç´¯ä¹˜

```c++
int main() {
    vector<int> a{1, 2, 3, 4};
    int sum = accumulate(a.begin(),a.end(),1,multiplies<int>()); 
    cout << sum << endl;	// è¾“å‡º24
}

```

æ‹¼æ¥å­—ç¬¦ä¸²

```c++
vector<string> words{"this ","is ","a ","sentence!"};
string init = "hello, ",res;
res = accumulate(words.begin(),words.end(),init);  // è¿æ¥å­—ç¬¦ä¸²
cout << res << endl;//hello, this is a sentence!
```



### rotateå‡½æ•°

rotate(first,n_first,last);

å¯¹ä¸€ç³»åˆ—å…ƒç´ æ‰§è¡Œå·¦æ—‹è½¬ï¼Œäº¤æ¢[first,last)èŒƒå›´å†…å…ƒç´ ï¼Œn_firstæˆä¸ºæ–°çš„ç¬¬ä¸€ä¸ªå…ƒç´ ï¼Œn_first-1æˆä¸ºæœ€åä¸€ä¸ªå…ƒç´ ã€‚

```c++
vector<int> a = {3,2,1};
for(auto &i:a)
{
	cout<<i<<" ";
}
cout<<"\n";
rotate(a.begin(),a.begin()+1,a.end());
for(auto &i:a)
{
	cout<<i<<" ";
}
3 2 1
2 1 3
```

##### rotateå‡½æ•°å®ç°

å°†xåˆ†ä¸ºabä¸¤æ®µï¼Œé€‰æ‹©xå…¶å®å°±æ˜¯äº¤æ¢abä½¿ä¹‹å˜ä¸ºbaã€‚è€ƒè™‘ä¸¤ç§æƒ…å†µï¼š
aæ¯”bçŸ­ï¼Œå°†abè¡¨ç¤ºä¸ºab1b2ï¼Œå…¶ä¸­aä¸b2é•¿åº¦ç›¸åŒï¼Œæœ€ç»ˆæˆ‘ä»¬éœ€è¦çš„æ˜¯b1b2aã€‚å…ˆäº¤æ¢aä¸b2ï¼Œå‘é‡å˜ä¸ºb2b1aï¼Œæ¥ä¸‹æ¥åªè¦äº¤æ¢b2b1å³å¯ã€‚
aæ¯”bé•¿ï¼Œå°†abè¡¨ç¤ºä¸ºa1a2bï¼Œå…¶ä¸­a1ä¸bé•¿åº¦ç›¸åŒï¼Œæœ€ç»ˆæˆ‘ä»¬éœ€è¦çš„æ˜¯ba1a2ã€‚å…ˆäº¤æ¢a1ä¸bï¼Œå‘é‡å˜ä¸ºba2a1ï¼Œæ¥ä¸‹æ¥åªè¦äº¤æ¢a2a1å³å¯ã€‚

æ¯”å¦‚123456ï¼Œæ­¤æ—¶äº¤æ¢å˜æˆ345612ï¼Œå¯ä»¥å…ˆå˜æˆ12|3456ï¼Œç„¶åå˜æˆ12|34|56,ç„¶åäº¤æ¢ä¸€æ¬¡ï¼Œå˜æˆ56|34|12ï¼Œæœ€åå˜æˆ34|56|12ã€‚

```c++
template <class ForwardIt>
void rotate4(ForwardIt first, ForwardIt middle, ForwardIt last)
{
    ForwardIt next = middle;
    while (first != next)
    {
        std::iter_swap (first++, next++);
        if (next==last) next = middle;
        else if (first==middle) middle = next;
    }
}
é€’å½’
template <class ForwardIt>
void rotate3(ForwardIt first, ForwardIt middle, ForwardIt last)
{
    if(first == middle) return;
    if(middle == last) return;
    ForwardIt oldmid = middle;
    while(first != oldmid && middle != last)
    {
        std::iter_swap(first++, middle++);
    }
    rotate3(first, first == oldmid ? middle : oldmid, last);
}
```

æ›´ç®€å•çš„æ–¹æ³•

ab,å…ˆå¯¹aæ±‚é€†ï¼Œç„¶åå¯¹bï¼Œæœ€åå¯¹æ•´ä½“ã€‚

æ¯”å¦‚1234567ï¼Œå…ˆå¯¹aä¸º2134567ï¼Œç„¶åbä¸º2176543ï¼Œæœ€åä¸º3456712ã€‚

$ab->a^rb->a^rb^r->(a^rb^r)^r=ba$ã€‚

```c++
reverse(first,middle);
reverse(middle,last);
reverse(first,last);
```



### next_permutationå‡½æ•°

ç”¨äºç”Ÿæˆåºåˆ—çš„å…¨æ’åˆ—ï¼Œ

```c++
int a[]={1,2,3};
do{
	cout<<a[0]<<" "<<a[1]<<" "<<a[2]<<"\n";
}while(next_permutation(a,a+3));
1 2 3
1 3 2
2 1 3
2 3 1
3 1 2
3 2 1
```

è‹¥å½“å‰è°ƒç”¨æ’åˆ—å·²ç»è¾¾åˆ°æœ€å¤§å­—å…¸åºï¼Œæ¯”å¦‚321ï¼Œå‡½æ•°è¿”å›falseã€‚

ä¿®æ”¹å‡½æ•°å‚æ•°ï¼Œ(a,a+2)ï¼Œå¯ä»¥åªå¯¹éƒ¨åˆ†é•¿åº¦å…¨æ’åˆ—ã€‚

### prev_permutationå‡½æ•°

ä¸next_permutationç›¸åï¼Œç”±åŸæ’åˆ—å¾—åˆ°å­—å…¸åºä¸­ä¸Šä¸€ä¸ªæœ€è¿‘æ’åˆ—ï¼Œå‰ä¸€ä¸ªå…¨æ’åˆ—

```c++
int a[]={3,2,1};
do{
	cout<<a[0]<<" "<<a[1]<<" "<<a[2]<<"\n";
}while(prev_permutation(a,a+3));
3 2 1
3 1 2
2 3 1
2 1 3
1 3 2
1 2 3
```

## Queue

```c++
queue<int> a;
a.push(3);//é˜Ÿåˆ—æ·»åŠ å…ƒç´ ï¼š
a.pop();//å»æ‰é˜Ÿé¦–å…ƒç´ ï¼š
a.front();//è®¿é—®é˜Ÿé¦–å…ƒç´ ï¼š
a.back();//è®¿é—®é˜Ÿå°¾å…ƒç´ ï¼š
a.empty();//åˆ¤æ–­æ˜¯å¦ä¸ºç©ºï¼š
a.size();//è¿”å›é˜Ÿåˆ—å¤§å°ï¼š
```

## Stack

```c++
stack<int> a;
a.push(3);//æ ˆé¡¶æ·»åŠ å…ƒç´ ï¼š
a.pop();//åˆ é™¤å…ƒç´ ï¼š
a.top();//è®¿é—®æ ˆé¡¶å…ƒç´ ï¼Œè¦å…ˆç¡®ä¿æ ˆéç©ºï¼š
a.empty();//åˆ¤æ–­æ˜¯å¦ä¸ºç©ºï¼š
a.size();//è¿”å›æ ˆå¤§å°ï¼š
```

æ ˆå’Œé˜Ÿåˆ—ä¸€æ ·æ²¡æœ‰clearå‡½æ•°ï¼Œéœ€è¦å¾ªç¯è°ƒç”¨å‡ºæ ˆå‡½æ•°

```c++
while(!s.empty())
{
	s.pop();
}
```

æ ˆçš„é—®é¢˜ä¸­å¯ä»¥å…ˆå…¥ä¸€ä¸ªç‰¹æ®Šå­—ç¬¦é˜²æ­¢REï¼Œé˜²æ­¢æ ˆç©ºçš„æ—¶å€™è®¿é—®æ ˆé¡¶



## String

### æ’å…¥å­—ç¬¦ä¸²

```c++
string s1("abcd");
string s2("12");
s1.insert(2,"123"); //s1 = "ab123cd" indexä¹‹å‰æ’å…¥
s1.insert(3,s2);//s1 = "abc12123cd"
s1.insert(3,5,'X');//s1="abcXXXXX12123cd" indexä¹‹å‰æ’å…¥5ä¸ªX
```

### åˆ é™¤å­—ç¬¦ä¸²

```c++
string s1("abcdlds");
s1.erase(1,3);//s1 = "alds";åˆ é™¤l-råŒºé—´æ‰€æœ‰å­—ç¬¦
s1.erase(1);//s1 = "a";ä»indexå¼€å§‹åˆ é™¤
```

äº¤æ¢ä¸¤ä¸ªStringå¯¹è±¡çš„å†…å®¹

swapæˆå‘˜å‡½æ•°äº¤æ¢ä¸¤ä¸ªStirngå¯¹è±¡çš„å†…å®¹

```c++
string s1("We");
string s2("Ce");
s1.swap(s2);//s1 = "Ce" s2 = "We"
```

### æŸ¥æ‰¾å­—ç¬¦ä¸²

```c++
std::string str = "yourlmelckme";
std::string key = "me";
int pos1 = str.find(key);     // 4 è¿”å›ç¬¬ä¸€ä¸ªæŸ¥æ‰¾åˆ°çš„é¦–å­—æ¯ä¸‹æ ‡,æŸ¥æ‰¾ç¬¬ä¸€æ¬¡å‡ºç°çš„ä½ç½®
int pos2 = str.find(key, 7);  // 17 æŸ¥æ‰¾[index,end]ç¬¬ä¸€æ¬¡å‡ºç°çš„ä½ç½®

std::string key2 = "aa";
auto it1 = str.find(key);
auto it2 = str.find(key2);

if(it1 != std::string::npos) {
    std::cout << it1 << std::endl;
} else {
    std::cout << "Not found!" << std::endl;
}

if(it2 != std::string::npos) {
    std::cout << it2 << std::endl;
} else {
    std::cout << "Not found!" << std::endl;
}
```

### Stringå¯¹è±¡æ¯”è¾ƒ

å¯ä»¥ä½¿ç”¨<ã€<=ã€==ã€!=ã€>=ã€>æ¯”è¾ƒï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨compareå‡½æ•°

### Stringå¯¹è±¡è¿æ¥

stringè¿æ¥å¯ä»¥ä½¿ç”¨+å’Œ+=è¿ç®—ç¬¦è¿›è¡Œï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨appendå‡½æ•°

```
str.append(3, 's');
//str="abc"
//str="abcsss"

str.append(str1);
//str="abc", str1="123"
//str="abc123"

str.append(str1, 2);
//åœ¨ str æœ«å°¾æ·»åŠ  str1[2]~str1[n-1]
//ä¾‹:str="abc", str1="123456"
//è¿è¡Œä¹‹å str="abc3456"

str.append(str1, 2, 3);
//åœ¨ str æœ«å°¾æ·»åŠ  str1[2]~str1[2+3-1]
//ä¾‹:str="abc", str1="123456"
//è¿è¡Œä¹‹å str="abc345"

str.append(str1.begin()+1,str1.end()-1);
//å°† str1 åŒºé—´å†…çš„å…ƒç´ æ·»åŠ åˆ° str æœ«å°¾
//ä¾‹:str="abc", str1="123456"
//è¿è¡Œä¹‹å str="abc2345"
```

### æ±‚Stringå¯¹è±¡çš„å­ä¸²

substr (size_t pos  = 0, size_t len = pos)

substrå‡½æ•°ç”¨äºä»å­—ç¬¦ä¸²ä¸­æå–å­—ç¬¦ä¸²ã€‚posæ˜¯å­—ç¬¦ä¸²å¼€å§‹çš„ä½ç½®ï¼Œé»˜è®¤ä¸º0ï¼Œlenæ˜¯æå–å­—ç¬¦ä¸²çš„é•¿åº¦ï¼Œå¦‚æœä¸æä¾›lenï¼Œnposå°†è¢«è®¤è¯é»˜è®¤å€¼ï¼Œæ„å‘³ç€å­—ç¬¦ä¸²å°†ä»poså¼€å§‹ä¸€ç›´å»¶ä¼¸è‡³æœ«å°¾ã€‚

```c++
std::string s = "Hello,World!";//ç´¢å¼•ä»0å¼€å§‹
//æå–æ•´ä¸ªå­—ç¬¦ä¸²
std::string sub = s.substr();
//sub = "Hello,World!"
//ä»å­—ç¬¦ä¸²ä¸­é—´æˆªå–
std::string sub = s.substr(6);//ä»ç´¢å¼•6å¼€å§‹
//sub = "world!"
//æå–ç‰¹å®šé•¿åº¦çš„å­å­—ç¬¦ä¸²
std::string sub = s.substr(6,2);//ä»ç´¢å¼•6å¼€å§‹æå–2ä¸ªå­—ç¬¦
//sub = "wo";
```

## Vector

vectorå‘é‡ï¼ŒåŠ¨æ€æ•°ç»„

```c++
vector<int> a;
a.begin();//å–é¦–å…ƒç´ çš„è¿­ä»£å™¨
a.end();//å–å°¾å…ƒç´ çš„ä¸‹ä¸€åœ°å€
a.front();//å–é¦–å…ƒç´ çš„å€¼
a.back();//å–å°¾éƒ¨çš„å€¼
int value0 = a[0];//ä¸‹æ ‡è®¿é—®
a.push_back(value);//å°¾éƒ¨æ·»åŠ ä¸€ä¸ªå…ƒç´ 
a.pop_back();//åˆ é™¤å°¾éƒ¨ç¬¬ä¸€ä¸ªå…ƒç´ 
a.empty();//åˆ¤ç©º
a.size();//æ±‚å‘é‡å…ƒç´ ä¸ªæ•°
```

vectorçš„å®šä¹‰

```c++
vector<int> a;//åˆå§‹åŒ–ä¸€ä¸ªsizeä¸º0çš„vector
vector<int> a(10);//åˆå§‹åŒ–10ä¸ªé»˜è®¤å€¼ä¸º0çš„å…ƒç´ 
vector<int> a(10,1);//åˆå§‹åŒ–äº†10ä¸ªå€¼ä¸º1çš„å…ƒç´ 
```

## Set

æœ‰åºæ€§ï¼Œæ‰€æœ‰æ“ä½œæ˜¯$log^n$ï¼Œçº¢é»‘æ ‘å®ç°ã€‚åªèƒ½ä½¿ç”¨è¿­ä»£å™¨è®¿é—®

ä½œç”¨ï¼šå»é‡ï¼Œå‡åºæ’åºã€‚

```c++
set<int> s;//å£°æ˜
s.clear();//æ¸…ç©º
s.insert(x);//æ’å…¥å…ƒç´ ï¼Œå¦‚æœä¹‹å‰æ²¡æœ‰ï¼Œåˆ™æ’å…¥åæ’åºï¼Œå¦åˆ™ä¸æ’å…¥ã€‚
int hav = s.count(x);//æŸ¥æ‰¾æ˜¯å¦æœ‰xï¼Œè¿”å›0æˆ–1
set<int>::iterator it = s.find(x);//æŸ¥æ‰¾xå¹¶è¿”å›è¿­ä»£å™¨
bool isempty = s.empty();//åˆ¤æ–­ç©ºé›†
int n = s.size();//å…ƒç´ ä¸ªæ•°
s.erase(x);//åˆ é™¤
```

### è®¿é—®

ä½¿ç”¨è¿­ä»£å™¨è®¿é—®ï¼Œæ³¨æ„setä¸æ”¯æŒ`it < st.end()`çš„å†™æ³•

```c++
set<int> st;
for(set<int>::iterator it = st.begin();it != st.end();it++)
{
	cout<<*it;
}

// since c++ 11
std::set<int> st = {1, 2, 3, 4, 5};
for(const auto& s : st) {
    std::cout << s << ' ';
}
```

### é™åºæ’åˆ—

```c++
set<int,greater<int> > st;
set<int,greater<int> >::iterator it;
st.insert(1);
for(it = st.begin();it != st.end();it++)
{
	cout<<*it;
}
```

å¦‚æœæ˜¯ç»“æ„ä½“ç±»å‹ï¼Œéœ€è¦åœ¨ç»“æ„ä½“ä¸­é‡è½½å°äºè¿ç®—ç¬¦ã€‚

* ä»¿å‡½æ•°å®šä¹‰

  ```cpp
  template<class T>
  struct Less {
      bool operator()(const T& x, const T& y) const {
          return x < y;
      }
  };
  
  template<class T>
  struct Greater {
      bool operator()(const T& x, const T& y) const {
          return x > y;
      }
  };
  
  int main() {
      std::set<int, Greater<int>> st = {1, 2, 3, 4, 5};
  
      for (const auto& s : st) {
          std::cout << s << ' ';
      }
      std::cout << std::endl;
  
      return 0;
  }
  ```

### unordered_set

åº•å±‚å®ç° hash tableï¼Œå­˜å‚¨å”¯ä¸€å¯¹è±¡é›†åˆ

#### éå†

```cpp
/**
 * éå† since c++ 11
 * å¯ä»¥çœ‹å‡º unordered_set æ˜¯æ— åºï¼Œä¸é‡å¤çš„
 */
template <class Os, class K>
Os& operator<<(Os& os, const std::unordered_set<K>& v) {
    os << '[' << v.size() << "] {";
    bool o{};
    for (const auto& e : v) {
        os << (o ? ", " : (o = 1, " ")) << e;
    }
    return os << " }";
}

std::unordered_set<int> us = {2, 7, 1, 8, 2, 8};
std::cout << us << std::endl;  // [4] { 8, 1, 7, 2 }
```

#### æ’å…¥å…ƒç´ 

O(1)

è‹¥é‡å¤åˆ™ä¸åšä»»ä½•äº‹ 

å¦‚æœæ“ä½œåæ–°çš„å…ƒç´ æ•°é‡å¤§äºåŸ max_load_factor() \* bucket_count() åˆ™ä¼šå‘ç”Ÿé‡æ•£åˆ—ã€‚å¦‚æœï¼ˆå› æ’å…¥è€Œï¼‰å‘ç”Ÿäº†é‡æ•£åˆ—ï¼Œç´¢å¼•è¿­ä»£å™¨å‡ä¼šå¤±æ•ˆã€‚å¦åˆ™ï¼ˆæœªå‘ç”Ÿé‡æ•£åˆ—ï¼‰ï¼Œåˆ™è¿­ä»£å™¨ä¸ä¼šå¤±æ•ˆã€‚

```cpp
us.insert(9);
std::cout << us << std::endl;  // [5] { 9, 8, 1, 7, 2 }
```

#### ç§»é™¤å…ƒç´ 

O(1)

```cpp
us.erase(us.begin());             // ç§»é™¤å¼€å¤´
us.erase(std::next(us.begin()));  // ç§»é™¤ç¬¬äºŒä¸ªå…ƒç´ 
std::cout << us << std::endl;     // [3] { 8, 7, 2 }

us.erase(7);                   // ç§»é™¤å…·ä½“å€¼
std::cout << us << std::endl;  // [2] { 8, 2 }

// iterator erase( const_iterator first, const_iterator last );
```

#### åˆå¹¶ä¸¤ä¸ªé›†åˆ

 O(N)

```cpp
std::unordered_set<char>
    p{'C', 'B', 'B', 'A'},
    q{'E', 'D', 'E', 'C'};

p.merge(q);
std::cout << "p: " << p << std::endl;  // p: [5] { E, D, A, B, C }
std::cout << "q: " << q << std::endl;  // q: [1] { C }
```

#### è¿”å›åŒ¹é…ç‰¹å®šé”®çš„å…ƒç´ æ•°é‡

åªè¦setä¸­å­˜åœ¨è¿™ä¸ªå…ƒç´ ï¼Œcountå°±è¿”å›1ï¼Œå¦åˆ™è¿”å›0

```cpp
std::unordered_set set{2, 7, 1, 8, 2, 8, 1, 8, 2, 8};
std::cout << set << std::endl;  // [4] { 8, 1, 7, 2 }

const auto [min, max] = std::ranges::minmax(set);  // since c++ 20
for (int i = min; i <= max; ++i) {
    if (set.count(i) == 1) {
        std::cout << i << ' ';
    }
}
std::cout << std::endl;
```

#### æŸ¥æ‰¾æŒ‡å®šå…ƒç´ 

æ‰¾å¾—åˆ°è¿”å›è¿­ä»£å™¨ï¼Œæ‰¾ä¸åˆ°è¿”å› end()

```cpp
if (auto res = set.find(2); res != set.end()) {
    std::cout << "Find: " << *res << std::endl;
} else {
    std::cout << "Not found!" << std::endl;
}
```

#### åˆ¤æ–­é›†åˆä¸­æ˜¯å¦å­˜åœ¨è¯¥å…ƒç´  *since c++ 20*

```cpp
for (int x : {2, 5}) {
    if (set.contains(x)) {
        std::cout << "Find: " << x << std::endl;  // Find: 2
    } else {
        std::cout << "Not found: " << x << std::endl;  // Not found: 5
    }
}
```

#### æ¸…ç©ºé›†åˆ

```cpp
set.clear();
std::cout << set << std::endl;  // [0] { }
```

### multiset

åº•å±‚å®ç°ï¼šçº¢é»‘æ ‘

å…è®¸å…ƒç´ é‡å¤

åŸºæœ¬æ“ä½œO(log n)

// TODO

## Map

é”®å€¼å¯¹(key/value)å®¹å™¨ï¼Œè¿­ä»£å™¨å¯ä»¥ä¿®æ”¹valueï¼Œä¸èƒ½ä¿®æ”¹keyã€‚Mapä¼šæ ¹æ®keyè‡ªåŠ¨æ’åºã€‚keyä¸ä¸€å®šæ˜¯intç±»å‹ï¼Œåªè¦æ˜¯é‡è½½çš„<æ“ä½œç¬¦çš„ç±»å‹å‡å¯

```c++
map<int,string>m;
m.count(k);//è¿”å›mä¸­é”®å€¼ç­‰äºkçš„å…ƒç´ ä¸ªæ•°
m.find(k);//å­˜åœ¨è¿”å›æŒ‡å‘å…ƒç´ çš„è¿­ä»£å™¨ï¼Œå¦åˆ™è¿”å›end()
m.erase(k);//åˆ é™¤mä¸­é”®ä¸ºkçš„å…ƒç´ ï¼Œè¿”å›åˆ é™¤å…ƒç´ çš„ä¸ªæ•°ã€‚
m.erase(p);//åˆ é™¤è¿­ä»£å™¨pæ‰€æŒ‡å‘çš„å…ƒç´ 
m.insert(e);//eæ˜¯ä¸€ä¸ªç”¨åœ¨mä¸Šçš„ä¸€ä¸ªpairï¼Œå¦‚æœe.firstä¸åœ¨mä¸­ï¼Œåˆ™æ’å…¥ä¸€ä¸ªå€¼ä¸ºe.secondçš„æ–°å…ƒç´ ï¼›å¦‚æœè¯¥é”®åœ¨mä¸­å­˜åœ¨ï¼Œä¸åšä»»ä½•æ“ä½œã€‚
m.clear();//æ¸…ç©º
m,empty();//åˆ¤ç©º
```

è®¿é—®

```c++
map<int,string>::iterator iter;
for(iter = mp.begin();iter != mp.end();iter++)
{
	cout<<iter->first<<" "<<iter->second<<endl;
}
```

```
auto it = mp.begin();
for(auto &[k,v]:mp)
{

}
```

#### unordered_map

// TODO

#### multimap

// TODO

## Pair

å®šä¹‰

```c++
pair<T1, T2> p1;            //åˆ›å»ºä¸€ä¸ªç©ºçš„pairå¯¹è±¡ï¼ˆä½¿ç”¨é»˜è®¤æ„é€ ï¼‰ï¼Œå®ƒçš„ä¸¤ä¸ªå…ƒç´ åˆ†åˆ«æ˜¯T1å’ŒT2ç±»å‹ï¼Œé‡‡ç”¨å€¼åˆå§‹åŒ–ã€‚
pair<T1, T2> p1(v1, v2);    //åˆ›å»ºä¸€ä¸ªpairå¯¹è±¡ï¼Œå®ƒçš„ä¸¤ä¸ªå…ƒç´ åˆ†åˆ«æ˜¯T1å’ŒT2ç±»å‹ï¼Œå…¶ä¸­firstæˆå‘˜åˆå§‹åŒ–ä¸ºv1ï¼Œsecondæˆå‘˜åˆå§‹åŒ–ä¸ºv2ã€‚
make_pair(v1, v2);          // ä»¥v1å’Œv2çš„å€¼åˆ›å»ºä¸€ä¸ªæ–°çš„pairå¯¹è±¡ï¼Œå…¶å…ƒç´ ç±»å‹åˆ†åˆ«æ˜¯v1å’Œv2çš„ç±»å‹ã€‚
p1 < p2;                    // ä¸¤ä¸ªpairå¯¹è±¡é—´çš„å°äºè¿ç®—ï¼Œå…¶å®šä¹‰éµå¾ªå­—å…¸æ¬¡åºï¼šå¦‚ p1.first < p2.first æˆ–è€… !(p2.first < p1.first) && (p1.second < p2.second) åˆ™è¿”å›trueã€‚
p1 == p2ï¼›                  // å¦‚æœä¸¤ä¸ªå¯¹è±¡çš„firstå’Œsecondä¾æ¬¡ç›¸ç­‰ï¼Œåˆ™è¿™ä¸¤ä¸ªå¯¹è±¡ç›¸ç­‰ï¼›è¯¥è¿ç®—ä½¿ç”¨å…ƒç´ çš„==æ“ä½œç¬¦ã€‚
p1.first;                   // è¿”å›å¯¹è±¡p1ä¸­åä¸ºfirstçš„å…¬æœ‰æ•°æ®æˆå‘˜
p1.second;                 // è¿”å›å¯¹è±¡p1ä¸­åä¸ºsecondçš„å…¬æœ‰æ•°æ®æˆå‘˜
```

åˆ›å»ºå’Œåˆå§‹åŒ–

```c++
pair<string, string> anon;        // åˆ›å»ºä¸€ä¸ªç©ºå¯¹è±¡anonï¼Œä¸¤ä¸ªå…ƒç´ ç±»å‹éƒ½æ˜¯string
pair<string, int> word_count;     // åˆ›å»ºä¸€ä¸ªç©ºå¯¹è±¡ word_count, ä¸¤ä¸ªå…ƒç´ ç±»å‹åˆ†åˆ«æ˜¯stringå’Œintç±»å‹
pair<string, vector<int> > line;  // åˆ›å»ºä¸€ä¸ªç©ºå¯¹è±¡lineï¼Œä¸¤ä¸ªå…ƒç´ ç±»å‹åˆ†åˆ«æ˜¯stringå’Œvectorç±»å‹
```

```c++
pair<string, string> author("James","Joy");    // åˆ›å»ºä¸€ä¸ªauthorå¯¹è±¡ï¼Œä¸¤ä¸ªå…ƒç´ ç±»å‹åˆ†åˆ«ä¸ºstringç±»å‹ï¼Œå¹¶é»˜è®¤åˆå§‹å€¼ä¸ºJameså’ŒJoyã€‚
pair<string, int> name_age("Tom", 18);
pair<string, int> name_age2(name_age);    // æ‹·è´æ„é€ åˆå§‹åŒ–
```

èµ‹å€¼

```c++
pair<int, double> p1(1, 1.2);
pair<int, double> p2 = p1;     // copy construction to initialize object
pair<int, double> p3ï¼›
p3 = p1;    // operator =
```

æ“ä½œ

```c++
pair<int ,double> p1;
p1.first = 1;
p1.second = 2.5;
cout<<p1.first<<' '<<p1.second<<endl;
//è¾“å‡ºç»“æœï¼š1 2.5
```

éå†

```

```

è¿­ä»£å™¨

```c++
vector<int> a;
vector<int>::iterator iter;
for(iter = a.begin();iter != a.end();iter++)
{
	cout<<*iter<<endl;
}
```

## tuple

// TODO

# å…¶ä»–

## int128

```c++
__int128 read() {
	char arr[30];
	__int128 res = 0;
	scanf("%s", arr);
	for (int i = 1; i <= strlen(arr); i++) {
		res *= 10;
		res += arr[i]-'0';
	}
	return res;
}
void print (__int128 num) {
	if (num > 9) { print(num / 10); }
	putchar(num % 10 + '0');
}

```



### å–ä¸€è¡Œå­—ç¬¦ä¸²

cin.getline(a,101);

ä½¿ç”¨æ‰«æä¸€è¡Œï¼Œæ‰«æä¸€è¡Œä¹‹å‰å…‰æ ‡åº”åœ¨å½“å‰è¡Œé¦–ï¼Œå¦‚æœæ²¡æœ‰åŠæ—¶æ¢è¡Œï¼Œé‚£ä¹ˆç¬¬ä¸€æ¬¡è¯»å–çš„å¯èƒ½ä¸ºç©ºï¼Œæ‰€ä»¥æœ‰æ—¶å€™åº”å½“åŠ å…¥getcharï¼ˆ)ä½¿å¾—å…‰æ ‡æ¢è¡Œã€‚

### å…³é—­è¾“å…¥è¾“å‡ºæµåŒæ­¥ï¼Œè§£ç»‘è¾“å…¥è¾“å‡ºæµ

```c++
ios::sync_with_stdio(0);
cin.tie(0);
cout.tie(0);
```

æ³¨æ„äº‹é¡¹ï¼š

1.ä¸é€‚ç”¨äºæ··åˆè¾“å…¥è¾“å‡ºï¼šå¦‚æœä½ çš„ç¨‹åºåœ¨è¾“å…¥è¾“å‡ºä¸­åŒæ—¶ä½¿ç”¨äº†C++çš„è¾“å…¥è¾“å‡ºæµå’ŒCæ ‡å‡†åº“çš„è¾“å…¥è¾“å‡ºå‡½æ•°ï¼ˆå¦‚scanfå’Œprintfï¼‰ï¼Œåˆ™ä¸åº”è¯¥ä½¿ç”¨è¿™æ®µä»£ç ã€‚å› ä¸ºè¿™ä¼šå¯¼è‡´è¾“å…¥è¾“å‡ºä¹‹é—´çš„ä¸åŒæ­¥ã€‚

2.ä¸èƒ½æ··ç”¨è¾“å…¥è¾“å‡ºå‡½æ•°ï¼šåœ¨ä½¿ç”¨äº†è¿™æ®µä»£ç åï¼Œåº”é¿å…ä½¿ç”¨Cæ ‡å‡†åº“çš„è¾“å…¥è¾“å‡ºå‡½æ•°ï¼ˆå¦‚printfå’Œscanfï¼‰ï¼Œå› ä¸ºè¿™äº›å‡½æ•°ä¸è¾“å…¥è¾“å‡ºæµçš„åŒæ­¥å·²è¢«å…³é—­ã€‚ç®€å•æ¥è¯´ï¼Œå…³é—­äº†åŒæ­¥æµï¼Œå°±ä¸èƒ½ç”¨scanfå’Œprintfã€‚

3.å…³é—­äº†åŒæ­¥æµï¼Œä¸èƒ½ç”¨getchar()å‡½æ•°ã€‚

4.ä¸å½±å“ç¨‹åºæ­£ç¡®æ€§ï¼šå…³é—­è¾“å…¥è¾“å‡ºæµçš„åŒæ­¥ä¸ä¼šå½±å“ç¨‹åºçš„æ­£ç¡®æ€§ï¼Œå®ƒåªæ˜¯ä¸ºäº†æé«˜ç¨‹åºçš„æ‰§è¡Œæ•ˆç‡ã€‚å› æ­¤ï¼Œåœ¨ä¸€äº›å¯¹è¾“å…¥è¾“å‡ºæ€§èƒ½è¦æ±‚è¾ƒé«˜çš„åœºæ™¯ä¸‹ï¼Œå¯ä»¥è€ƒè™‘ä½¿ç”¨è¿™æ®µä»£ç ã€‚

5.å…³é—­äº†åŒæ­¥æµï¼ˆä¹Ÿå°±æ˜¯ä½¿ç”¨è¿™æ®µä»£ç ï¼‰ï¼Œä¸èƒ½å†ç”¨cout<<endlã€‚è€Œåº”è¯¥æ”¹ç”¨cout<<'\n'ã€‚

å› ä¸ºé€šå¸¸æƒ…å†µä¸‹ï¼Œcout<<endlä¼šè¾“å‡ºä¸€ä¸ªæ¢è¡Œç¬¦å¹¶åˆ·æ–°è¾“å‡ºç¼“å†²åŒºï¼Œç¡®ä¿å†…å®¹ç«‹å³æ˜¾ç¤ºã€‚ä½†æ˜¯ï¼Œå½“ä½¿ç”¨äº†ä¸Šè¿°ä»£ç æ—¶ï¼Œcout<<endlä¸å†å…·æœ‰è‡ªåŠ¨åˆ·æ–°ç¼“å†²åŒºçš„åŠŸèƒ½ã€‚
6.è¿™ä¸‰è¡Œä»£ç å¿…é¡»ä¸€èµ·ç”¨ï¼Œä¸èƒ½åªç”¨ç¬¬ä¸€è¡Œä»£ç ï¼Œä½¿ç”¨è¿™ä¸‰è¡Œä»£ç æ—¶ï¼Œå¾—ç”¨C++çš„å¤´æ–‡ä»¶ã€‚ç®—æ³•ç«èµ›ä¸ºäº†æ–¹ä¾¿ï¼Œä¸€èˆ¬ä½¿ç”¨ä¸‡èƒ½å¤´æ–‡ä»¶bits/stdc++.hã€‚

## æ³¨

å¦‚æœè¦åˆ é™¤ç¬¬ä¸€ä¸ªå’Œç¬¬äºŒä¸ªå…ƒç´ ï¼Œ

ä¸æ˜¯erase(a.begin());å’Œerase(a.begin()+1)ï¼Œè€Œæ˜¯ä¸¤æ¬¡erase(a.begin())ã€‚å³ç¬¬ä¸€æ¬¡åˆ é™¤ä¼šæ”¹å˜æ‰€æœ‰å…ƒç´ çš„ä½ç½®ã€‚

æ³¨æ„$i*i$æˆ–è€…$n*n$ä¼šçˆ†LLï¼Œå¤šä¹˜ä»¥ä¸€ä¸ª1LLã€‚

ä½¿ç”¨stlä¸€å®šè¦åœ¨æ¯æ¬¡æµ‹è¯•æ ·ä¾‹ç»“æŸååˆå§‹åŒ–

